Q.What is Java?
-Java is programming lang. which is high-level, robust, object-oriented and secure programming language.

Q.Features of Java?
-Platform independent.
-Robust.
-Simple and secured.
-Portable.

Q.JDK, JRE and JVM?

-Java Development Kit?
 To develop and run java application jdk environment is required.

-Java Runtime Environment?
 Just to run the java application JRE is required.

-Java Virtual Machine?
 It is interpreter which runs the java program line by line.

JDK = JRE + Development kit.
JRE = JVM + libraries.

Q.Virtual Machine?
-It is software simulation of machine which can perform operations like a physical machine.

Q.Hardware based VM?
-It provides several logical system on same computer with strong isolation from each other.

Q.Software based VM?
-This VM's act as a runtime engine to run java based applications.

Q.Features of ClassLoader?
 ClassLoader is responsible for the following three activities:
 -Loading
   1.Loading means reading .class file and store it's corresponding binary data in method area.
   2.For each .class file JVM will store it's corresponding data in method area with fully qualified name of class and fully qualified immediate parent class name.
   3.Also stores method information, variable information, constructor information, modifiers information.
   4.ClassLoader creates the object of class Class for each class loaded in the method area and stores that object inside heap area and stores all the information
     inside that object about the corresponding class.
 
 -Linking
   It consists of three activities:
   a.Verify
     It is the process of ensuring that binary representative of a class is structurally correct or not. That is, JVM will check whether .class file is generated by
     valid compiler or not. Whether .class file properly formatted or not. Internally bytecode verifier is responsible for this activity. Bytecode verifier is a part of
     ClassLoader.
     If verification failed then we'll get runtime exception called java.lang.VerifyError.
   b.Prepare
     In this phase JVM will allocate memory for class level static variables and assign it's default value.
     NOTE :- In initialization phase original values will be assigned to the static variables and default values will be assigned in the prepare phase.
   c.Resolve/Resolution
     It is the process of replacing symbolic names in our program with original memory reference from method area.
   
 -Initialization
   In this all static variables are assigned with original values and static block will be executed from parent to child and from top to bottom.

   
	LOADING ----> VERIFY
                        |
                      PREPARE  ------> INITIALIZATION
                        |
                      RESOLVE

  NOTE :- While loading, linking or intialization if any error occurs then we will get runtime exception saying  java.lang.LinkageError.

Q.Types of ClassLoader?
1.BootStrap ClassLoader / Pre-modular ClassLoader
   It is responsible to load core java API classes i.e., the classes present in rt.jar.
   JDK ---> JRE ---> Libraries ---> rt.jar
   BootStrap ClassLoader is responsible to load classes from class path.
   BootStrap ClassLoader is by default present with every JVM. It is implemented in native language and not implemented in java.
2.Extension ClassLoader
   Extension ClassLoader is the child class of BootStrap ClassLoader.
   JDK ---> JRE ---> Libraries ---> Extension(folder) ---> *.jar files.
   Responsible to load classes from extension class path. It is implemented in java language and the corresponding class file is oracle.misc.Launcher$extClassLoader.class.
   $ --> inner class.
3.Application ClassLoader / System ClassLoader
   It is the child class of Extension ClassLoader.
   It is responsible to load classes from application class path. Loads all the application files.
   It internally uses environment variable class path.
   It is implemented in java language
   oracle.misc.Launcher$appClassLoader.class

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

JAVA FUNDAMENTALS:
1.Identifiers
  A name in java programs are by default called identifiers which is used for identification purpose.
  It can be class name, method name, variable name and lables.
  E.g:  class Test {
	   public static void main(String[] args) {
               int x = 10;
           }
        }

  Rules for defining java Identifiers:
  i. The only allowed characters for java identifiers are a-z, A-Z, 0-9, $, _ . If we're using any other characters then we'll get compile time error.
     e.g. int total --- valid.
          int total# --- invalid.
  ii.Identifiers cannot start with digit.
  iii.Java identifiers are case-sensitive.
      e.g. class Test {
              int number = 10;
	      int Number = 20;
              int NUMBER = 30;
           }
  iv.There is no length limit for java identifiers but it is very wrong practice and not recommended to take too lengthy identifers.
  v.Identifers cannot be any reserved word.
    e.g. int x = 10;  --> valid
         int if = 20; --> invalid
         class Test {
            public static void main(String[] args) {
               int String = "888"; //valid
            }
         }
  vi.All the predefined java classes and interface name can be used as identifiers.

  Which of the following are java valid identifiers?
  1.total_number - valid
  2.total# - invalid
  3.total123 - valid
  4.cash - valid
  5.cas$h -valid
  6_$_$_$ - valid
  7.java2share - valid
  8.Integer - valid
  9.int - invalid

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2.Reserved Words
  In java some words are reserved to represent some meanings and functionality. Such type of words are called reserved words.

                                                               Reserved Words(53)
                                                          ______________|_____________
                                                         |                            |
                                                    Keywords(50)                Reserved Literals(3) (null, true, false)
                                               _________|_________
                                              |                   |
                                         Used Keywords(48)      Unused Keywords(2) (goto, const)


  Q.What is the difference between reserved literals and keywords?
  -Reserved words associated with the functionality is called Keywords and the reserved words associated with values is called reserved literals.

  Keywords for Data Types:
  i.byte
  ii.short
  iii.int
  iv.long
  v.float
  vi.double
  vii.boolean
  viii.char

  Keywords for flow control:
  i.if
  ii.else
  iii.switch
  iv.case
  v.default
  vi.while
  vii.do
  viii.for
  ix.break
  x.continue
  xi.return

  Keywords for modifiers:
  i.public
  ii.private
  iii.protected
  iv.static
  v.final
  vi.abstract
  vii.synchronized
  viii.strictfp
  ix.transient
  x.volatile

  Keywords for Exception Handling:
  i.try
  ii.catch
  iii.throw
  iv.throws
  v.finally
  vi.assert

  Class related Keywords:
  i.class
  ii.interface
  iii.extends
  iv.implements
  v.package
  vi.import

  object related keywords:
  i.new
  ii.instanceof
  iii.super
  iv.this

  void keyword:
   -In java return type is mandatory. If method doesn't return anything then we have to declare that method with void return type.

  Unused Keywords:
  i.goto
    -Uses of goto created several problems in old languages like C, C+ and hence sun people banned this keyword in java.
  ii.const
    -Use final instead of constant.
  NOTE :- goto and const are unused keywords and if we're trying to use then we'll get compile-time error

  Reserved Literals:
  i.true, ii.false ---> these are the values for boolean data type.
  iii. null ---> default value for object reference.

  enum keyword:
  - We can use enum to define a group of named constants.

Some Common Conclusions:
-All 53 reserved words in java contains lowercase symbols.
-In java we have only new keyword because destruction of useless objects is responsibility of garbage collector.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3.Data Types
  -In java every variable and every expression has some type.
  -Each and every data type is clearly defined.
  -Every assignment should be checked by compiler for type compatibility.
   Because of above reasons we can conclude java as a strongly typed programming language.
 
 Q.Why java is not a pure object oriented programming language?
 -Java is not considered as pure OOP language because several OOPS features are not satisifed by java like operator overloading, multiple inheritance, etc.
  Moreover, we're depending on primitive data types which are non-object.

                                                                 Primitive Data type
                                                __________________________|_____________________________
                                               |                                                        |
                                      Numeric Data type                                        Non-Numeric Data Type
                                 _____________|_____________                                 ____________|_____________
                                |                           |                               |                          |
                             Integral                Floating-point                      character                  boolean
                                |                           |
                             1.byte                     1.float
                             2.short                    2.double
                             3.int
                             4.long

 -Except boolean and char remaining data types are considered as signed data type because we can represent both positive and negative numbers.

 Numeric Data types:
  I.byte:
    1 byte = 8 bits
    MSB --> 0 --> +ve
    MSB --> 1 --> -ve
    range : -128 to +127
    Positive numbers will be represented directly whereas negative numbers will be represented in 2's complement forms.
    By default compiler treats any integral data as int.
    
    Best uses:
    -byte is the best choice if we want to handle data in terms of streams either from the file or from the network.

  II.short:
    -This is the most rarely used data type in java.
     size:- 2 bytes
    
     Best uses:
     -short data type is best suitable for 16-bit processors like 8085 but these processors are completely outdated and hence corresponding short data type is outdated
      data type.

  III.int:
    -The most commonly used data type in java is int.
    -size: 4 bytes
    -range: -2147483648 to 2147483647

  IV.long:
    -Sometimes int may not enough to hold big value then we should go for long data type.
    -size: 8 bytes
   
    Note: All the above data types (byte, short, int, long) meant for representing integral values.

 Floating-point Data types:
  I.float:
   -size: 4 bytes
   -If we want 5-6 decimal places of accuracy then we go for float data type.

  II.double:
   -size: 8 bytes
   -If we want 14-15 decimal places of acccuracy then we go for double data type.

 boolean data type:
 -size: NA (It depends on VM)
 -range: not defined but allowed values are true/false.

 e.g.: boolean b = true;  //valid
       boolean b = 0; // compilation error, cannot convert int to boolean
       boolean b = True;  // compilation error, True cannot be resolved to a variable
       boolean b = "true"; //type mismatch error

       int x = 0;
       if(x) {  //decision making strictly requires boolean value in java, type mismatch error, cannot convert int to boolean
         System.out.println("Hello");
       }
       else {
         SOP("Hi");
       }
          
       while(1) { //decision making strictly requires boolean value in java, type mismatch error, cannot convert int to boolean
            ....
            ....
       }

 char data type:
 -Old languages like C, C++ are ASCII code based and the number of allowed different ASCII codes characters are less than or equal to 256.
 -To represent this 256 characters 8 bits are enough. Hence, the size of characters in old languages is 1 byte.
 -But java is unicode based language and the number of different unicode characters are greater than 256 and less than or equal to 65536.
 -To represent this many characters 8 bits are not enough we should compulsorily go for 16 bits. So the memory management of character is 2 bytes.

 Summary of Primitive Data types:

 Data type        Size       Wrapper Class       Range                 Default Value

  byte           1 byte          Byte         -128 to +127                  0
  short          2 bytes         Short        -2^15 to (2^15)-1             0
  int            4 bytes        Integer       -2^31 to (2^31)-1             0
  long           8 bytes         Long         -2^63 to (2^63)-1             0
  float          4 bytes        Float         -3.4E38 to 3.4E38            0.0
  double         8 bytes         Double       -1.7E38 to 1.7E38            0.0
  boolean         NA            Boolean          NA                       false
  char           2 bytes       Character         NA                        '\0'

 NOTE: null is not allowed for primitive data type. null is default value for object reference and we cannot apply it for primitive data type.
       If we're trying to use null for primitive data type we'll get compile-time error.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4.Literals
 -A constant value which can be assigned to the variables is called literals.
  e.g. int x = 10;   // 10 is literal here
  
 I. Integral Literals
    -For integral data types we can specify literal values in following ways:
     i.Decimal literal(Base 10)
       -Allowed digits are 0-9.

     ii.Octal literal(Base 8)
       -Allowed digits are 0-7.
       e.g. int x = 010;

     iii.Hexadecimal literal(Base 16)
       -Allowed digits are 0-9, A-F
       -For extra digits we can use both lower and upper case characters.
       -This is one of very areas where java is not case sensitive.
       -prefixed with 0x or 0X.
       e.g. int x = 0x10;

     -These are the only ways to specfiy literal values for integral data type. By default every integral literal is of int type but we can specify explicity as long type
      by adding suffix with l or L.
     -There is no direct way to specify byte and short literals explicitly but indirectly we can specify.
     -Whenever we're assigning integral literal to the byte variable and the value within the range of byte then compiler treats it automatically as byte.
     -Similarly with short literals also.

 II.Floating-point literals:
    -By default every floating-point literal is of double type and hence we cannot assign directly to the float variable. But, we can specify floating-point literals as float
     type by adding suffix with f or F.
     e.g. float f = 123.456;      //type mismatch, cannot convert from double to float
          float f = 123.456f;    //valid
          double d = 123.456;    //valid
    -We can specify explicitly floating point literals as double type by suffixed with d or D.
     e.g. double d = 123.456d;    //valid
    -We can specify floating point literals only in decimal form cannot specify in octal or hexadecimal form.
     e.g. double d = 123.456;  //valid
          double d = 0123.456; //valid
          double d = 0x123.456 //invalid
    -We can assign integral literals directly to floating point variables and that integral literal can be specified in decimal, octal or heaxdecimal.
     e.g. double d = 0xface;  //valid
          double d = 0777;  //valid
          double d = 0xface.0;  //invalid
    -We cannot assign floating-point literal to integral type.

  III.Boolean literals:
      -The only allowed values for boolean data type are true and false.

  How Automatic promotion works in java:

  byte ---> short ---> int ---> long ---> float ---> double
                       |
              char -----

  IV.Character Literals:
     -We can specify character literals as integral literals which represents unicode value of the character and that integral literal can be specified either in decimal or
      octal or hexadecimal.
     -We can represent character literals in unicode representation which is nothing but single code.
     -Every newline character is a valid character literal.
      \n - newline
      \t - horizontal tab
      \r - carriage return
      \b - backspace
      \f - formfeed
      \' - single quote
      \" - double quote
      \\ - backlash

      e.g. char ch = 0xbear;  //invalid
           char ch = '\m';    //invalid
      Note: any sequence of characters within double quotes is treated as string literals.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

5.Arrays
  I.Array Introduction
   -An array is an indexed collection of fixed number of homogenous data elements.
   -The main advantage of array is we can represent huge number of values using single variable so that readability of the code will be improved.
   -The main disadvantage of array is that it is fixed in size i.e., once we create an array there is no chance of increasing or decreasing the size based on our requirement.
    Hence, to the array concept complusory we should know the size in advance which is not possible always.

  II.Array declaration
    a.One dimensional array:
      -Ways to declare :
       int[] x;
       int x[];
      -At the time of declaration we cannot specify the size otherwise we'll get compile-time error.
    
    b.Two dimensional array:
      - int[][] x;
        int x[][];
        int []x[];
      -If we want to specify dimension before the variable, this facility is applicable only for first variable. If we're trying to apply for remaining variables
       then we'll get compile-time error.
                   


  III.Array creation
     int [] x = new int[5] ;
    -For every type, corresponding classes are available and these classes are part of the java language and not available to the programmer.
 
     Type of Array               Corresponding classes
        int []                            [I
        int [][]                          [[I
        double[]                          [D
        short[]                           [S
        byte[]                            [B
        boolean[]                         [Z
    
    -At the time of array creation compulsory we should specify the size otherwise we'll get compile-time error.
    -It is legal to have an array with size zero in java.
    -If we're trying to specify array size with some negative int values, then we'll get runtime exception saying NegativeArraySizeException. At compile-time no error
     as it is checking for only int value.
    -To specify array size the allowed data types are: byte, short, char, int. If we're trying to specify any other types then we'll get compile-time error.
     
     e.g. int[] x = new int[10];
          int[] x = new int['a'];
  
          byte b = 20;
          int[] x = new int[b];

          short s = 30;
          int[] x = new int[s];

          int[] x = new int[10l];  //invalid, type mismatch

     Two dimensional array:
     -In java 2D array not implemented by using matrix style. Sun Microsystems people followed array of arrays approach for multi-dimensional array creation.
     -The main advantage of this approach is memory utilization will be improved.

      int[][] x = new int[2][];
      x[0] = new int[2];
      x[1] = new int[3];

      int[][][] x = new int [2][][];
      x[0] = new int[3][];
      x[0][0] = new int[1];
      x[0][1] = new int[2];
      x[0][2] = new int[3];
      x[1] = new int[2][2];
      x[1][0] = new int[2];
      x[1][1] = new int[2];
 
      Q.Which of the following array declaration is valid?
        1.int[] a = new int[];  //invalid
        2.int[] a = new int[3]; //valid
        3.int[][] a = new int[][]; //invalid
        4.int[][] a = new int[3][]; //valid
        5.int[][] a = new int[][4]; //invalid
        6.int[][] a = new int[3][4]; //valid
        7.int[][][] a = new int[3][4][5]; //valid
        8.int[][][] a = new int[3][][5]; //invalid
        9.int[][][] a = new int[][4][5]; //invalid

  IV.Array initialization
    -int[] x = new int[3];
     System.out.println(x);  //prints hashcode of the object

     NOTE: Once we create an array every array element is initialized with default value 0.
           Whenever we're trying to print any reference variable internally toString() method will be called, which is implemented by default to return the string in the
           following form:
           ClassName@(Hashcode in hexadecimal)

     e.g. int[][]x = new int[2][3];
          SOP(x);  // [[I@.....
          SOP(x[0]);  //[I@.....
          SOP(x[0][0]);  //0

          int[][]x = new int[2][];
          SOP(x);  // [[I@.....
          SOP(x[0]);  null
          SOP(x[0][0]);  //NullPointerException

     NOTE: If we're trying to perform any operation on null then we'll get runtime exception saying NullPointerException.
     
     Once we create an array, every array element by default initialized with default values. If we're not satisfied with default values then we can override with 
     our customized values.

     NOTE: If we're trying to access array element without range index(either positive value or negative value) then we'll get runtime exception saying
           ArrayIndexOutOfBoundsException.


  V.Declaration, creation and initialization in single line:
   -We can declare, create and initialize array in a single line(shortcut representation)
    e.g. int[] x = {10, 20, 30};

   -We can use this for multi-dimensional array also.
    e.g. int[][] x = {{10, 20}, {30, 40, 50}};
         int[][][] x = {
                         {{10, 20, 30}, {40, 50, 60}},
                         {{70, 80}, {90, 100, 110}}
                       };

    Note: If we want to use the shortcut compulsory we should perform all the activities in single line. If we're trying to divide into multiple lines then we'll get
          compile-time error.

  VI.length v/s length()
     length: 
     -It is final variable applicable for arrays.
     -It represents the size of the array.

     length():
     -It is a final method applicable for String object.
     -It represents number of characters in a string.
     NOTE: length variable is applicable for arrays not for String object whereas length() is applicable for String object but not for arrays.
  
     e.g. int[][] x = new int[6][3];
          SOP(x.length);  //6
          SOP(x[0].length);  //3
     NOTE: There is no direct way to find total length of multi-dimensional array but indirectly we can find using sum of individual array lengths.

  VII.Anonymous arrays
     -Sometimes we can declare an array without name. Such type of nameless arrays are called anonymous arrays. The main purpose of anonymous arrays is just for
      instant use(one-time use).
     -while creating anonymous arrays we cannot specify size otherwise we'll get compile-time error.
  
     NOTE: Based on our requirement we can give the name on anonymous array but then it is no longer anonymous array.


  VIII.Array element assignment:
      CASE 1: In the case of primitive type arrays as array element we can provide any type which can be implicitly promoted to declared type.
              e.g. int[] x = new int[5];
                   x[0] = 10;
                   x[1] = 'a';
                   byte b = 20;
                   x[2] = b;
                   short s = 30;
                   x[3] = s;

              e.g.In the float type arrays the allowed data types are byte, short, int, char, long.

      CASE 2: In the case of object type of arrays as array elements we can provide either declared type object or it's child class object.
              e.g. Object[] a = new Object[10];
                   a[0] = new Object();
                   a[1] = new String("Sarthak");
                   a[2] = new Integer(10);

      CASE 3: For interface type of arrays as array elements it's implementation type class object are allowed.
              e.g. Runnable[] r = new Runnable[3];
                   r[0] = new Thread();

  Summary:

     Array type                 Allowed element type
    Primitive type        Array type which can be implicity promoted
                           to declared type.

    Object type          Either declared type or it's child class type.

    Abstract type        It's child class's object.

    Interface type       It's implementation class type objects are
                         allowed.
        

  IX.Array variable assignment:
    -CASE 1: Element level promotions are not applicable at array level.
             e.g. int[] x = {10, 20, 30, 40};
                  char[] ch = {'a', 'b', 'c, 'd'};

                  int[] a = x;   //valid
                  int[] b = ch;  //invalid

             -char element can be promoted to int type whereas char array cannot be promoted to int array.

             Q.Which of the following promotion will be performed automatically?
               1.char to int - valid
                 char[] to int[] - invalid
                 int to double - valid
                 int[] to double[] - invalid
                 float to int - invalid
                 float[] to int[] - invalid
                 String to Object - valid
                 String[] to Object[] - valid - In this case Object type arrays child class arrays can be promoted to parent type arrays. (Loophole)

    -CASE 2: Whenever we're assigning one array to another array, internal elements won't be copied just reference variable will be re-assigned.

    -CASE 3: Whenever we're assigning one array to another array, the dimension must be matched.
             e.g. In place of 1-D int array we should provide 1-D int array only. If we're trying to provide any other dimension then we'll get compile time error.
      NOTE: Whenever we're assigning one array to another array, both dimension and type must be matched but sizes are not required to match.
       
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

6.Types of Variables
 -Based on type of values represented by variable all variables are divided into two types:
  1.Primitive Variable
   -They can be used to represent primitive values.
  2.Reference Variable
   -Can be used to refer object
 
 -Based on position of declaration and behaviour all variables are divided into three types:
  1.Instance Variables
   -If the values of a variable is varied from one object to another object, such type of variables are called instance variables.
   -For every object a separate copy of instance variables will be created.
   -Instance variables should be declared within a class directly but outside of any method, block and constructor.
   -Instance variable will be created at the time of object creation and destroyed at the time of object destruction. Hence, the lifetime of instance variable is exactly the
    life of object.
   -Instance variable will be stored in heap memory as the part of object.
   -We cannot access instance variable directly from static area but we can access by using reference and we can access instance variable directly from instance area.
   -For instance variable JVM will always print default values and we're not required to perform initialization explicitly.
   -Instance variable is also known as object-level variable or attribute.

  2.Static Variables
   -If the value of a variable is not varied from object to object then it is not recommended to declare variables as instance variable. We have to declare such type of variable at
    class level by using static modifier.
   -In the case of instance variable, for every object a separate copy will be created. But in this case of static variable a single copy will be created at class level and
    should be shared by every object of the class.
   -Static variable should be declared within the class directly but outside of any method, block, and constructor.
   -Static variable will be created at the time of class loading and destroyed at the time of class unloading. Hence the lifetime of the static variable is exaclty same
    as .class file.
    
    Whenever we run the program:
    1.Start JVM.
    2.Create and run main thread.
    3.Locate .class file from hard disk.
    4.Load .class file -> static variable creation
    5.Execute main()
    6.Unload .class file -> static variable destruction
    7.Terminate main thread.
    8.Shutdowm JVM.

   -Static variable will be stored in method area.
   -We can access static variable either by object reference or by classname but recommended to use classname, if within the same class it is not required to use classname
    and we can access directly.
   -For static variable JVM will provide default values and we're not required to perform initialization explicitly.
   -Static variables are known as class level variables or field.

  3.Local Variables
   -Sometimes to meet the temporary requirement of the program we can declare variables inside a mehotd or block or constructor. Such type of variables are called local variables
    or temporary variable or stack variable or auotmatic variable.
   -Local variables will be stored inside stack memory.
   -Local variables will be created while the block/method in which we declared it. Once block/method execution completes automatically local variables will be destroyed.
    Hence the scope of local variable is the block/method in which we declared it.
   -For local variable JVM won't provide default value compulsory we should perform initialization explicity. Before using the variable i.e., if we're not using then it is not 
    required to perform intialization.
   -It is not recommended to perform initialization for local variable inside logical block because there is no guarantee for the execution of these blocks always at runtime
   -It is highly recommended to perform initialization at the time of declaration.
   -The only applicable modifiers for local variables is final. By mistake if we're trying to apply any other modifiers then we'll get compile-time error.
  
  NOTE: If we're not declaring any modifiers then by default it is default but this rule is applicable only for instance and static variables but not for local variables.

  Concluions:
  -For instance and static variables JVM will provide default values and we're not required to perform initialization explicitly but for local variable JVM won't provide default
   values. Compulsory we should perform intialization explicitly for local variables before using it.
  -Every variable in Java should be either instance, static or local variable.
  -Every variable in Java should be either primitive or Reference variable.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

7.var-args method:
 -Until 1.4 version we cannot declare a method with variable number of arguments. If there is change in number of arguments compulsory we should go for new method. It increase length of
  code and reduces readability. To overcome this problem, Java people introduced var-args method in 1.5 version. According to this we can declare the method which can take variable number
  of arguments.
 -Internally var-args parameters will be converted into 1-D array. Hence, within the var-args method we can differentiate values by using index.

  CASE 1: Q.Which of the following are valid var-args method?
            1.m1(int... x) - valid
            2.m1(int   ...x) - valid
            3.m1(int...x) - valid
            4.m1(int x...) - invalid
            5.m1(int. ..x) - invalid
            6.m1(int .x..) - invalid

  CASE 2: We can mix var-args parameter with normal parameter.
          int add(int x, int... y)
          int m1(String s, double... z)

  CASE 3: If we mix normal parameters with var-args parameter then var-args parameter should be last parameter.

  CASE 4: Inside var-args method we can take only one var-args parameter and we cannot take more then one var-args parameter.

  CASE 5: Inside a class we cannot declare var-args method and corresponding one 1-D array method simultaneously otherwise we'll get compile-time error.
          e.g. public static void m1(int... x) {
                  ....
               }

               public static void m2(int[] x) {
                  ....
               }
  
               Both the above methods will be treated as same by the Java compiler. Hence, Overloading will not be possible.

  NOTE: In general var-args method will get least priority i.e., if no other method match then only var-args method will get the chance.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

8.main method
  public static void main(String[] args) {
     ...
  }

  public: It should be accessible to JVM outside the class.

  static: Without existing object also JVM has to call this method.

  -Whether class contains main method or not and whether main method is declared according to requirements or not, these things won't be checked by compiler at runtime
   JVM is responsible to check all these things. If JVM is unable to find main method then we'll get runtime exception saying "No such method error: main".
  -At runtime JVM always search for main method.
  -Instead of main we can change the name of main method to any name but customization of JVM is required because in JVM main method is configured.
  -The syntax of main method is very strict if we perform any change we'll get runtime exception.
  -Eventhough syntax is very strict the following changes that can be acceptable are:
   1.Order of modifiers are not important.Instead of public static we can write static public.
   2.We can declare String array in any acceptable form.
   3.Instead of args we can take any valid Java identifier.
   4.We can replace String array with var-args parameter.
   5.We can declare main method with following modifiers:
     final, synchronized, strictfp
     final synchronized strictfp static public void main(String[] args) {
         ....
     }
     Above is valid declaration.
   
   Q.Which of the following main method declarations are valid?
   public static void main(String args) - invalid
   public static void Main(String[] args)  - invalid
   public void main(String[] args) - invalid
   public static in;lt main(String[] args) - invalid
   final synchronized strictfp public void main(String[] args) - invalid
   final synchronized strictfp public static void main(String[] args) - valid
   public static void main(String... args) - valid

   NOTE: In all the above cases we won't get compile-time error but we'll get runtime error.
         Overloading of main method is possible but JVM will call that main method which has String[] as parameter. Other main methods we have to call explicitly.
         Inheritance concept applicable for main method hence while executing child class if child does not contain main method then parent class main method will be executed.
         For main method overloading concept are applicable and overriding concept is not applicable.
         It seems overriding concept for main method is not applicable but most of the people think it is overriding but it is method hiding.
         return type of method must be same in overriding until java 1.5 version after that different data types are allowed.
  
  Important change in main method after Java 1.7 version:
  -Until Java 1.6 if the class does not contain main method then we'll get runtime excpetion saying "no such method error: main" but from 1.7 version onwards we'll get more ellaborated
   error information.
  -From 1.7v onwards main method is mandatory to start program execution. Hence, even though class contain static block it won't be executed if the class does not contain main method.
  -static block will get higher preference than main and it will be executed before main method.
  -If multiple static blocks are present then they will be executed in top to bottom manner.

  Flow of execution:
  Upto 1.6 version:
   1.Identification of static variables and blocks
   2.Assignment of static variables and execute static block
   3.Search for main method (if not found then error "No such method found error: main()" )
   4.If main method present then execute it.

  From 1.7 version and onwards:
   1.Check for main method (if not found then gives error).
   2.If main method available then, Identification of static variables and blocks.
   3.Assignment of static variables and execute static block.
   4.main() execution.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9.Command-line arguments
 -The arguments which are passing from command prompt are called command-line arguments. With these command-line argument JVm will create an array and by passing that array as argument
  JVM will call main method.
 -The main objective of command-line arguments is we can customize behaviour of main.
 -The main method is having parameter String[] args bcoz String is the most common used in any java application and if the type is not String it is very simple to convert
  from any data type.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
10.Java Coding standards

Programs for practice:
1.Addition 
2.Subtraction
3.Simple Interest Program

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ACCESS SPECIFIERS:
Q.How many public class should be there in Java Application?
  -Atleast one.

Modifiers in Java:

Access Specifier       Outer Class      Inner Class    Method     Variable            
 public                    y                y            y           y
 private                   n                y            y           y
 protected                 n                y            y           y
 default                   y                y            y           y
 final                     y                y            y           y
 abstract                  y                y            y           n
 static                    n                y            y           y
 strictfp                  y                y            y           n
 transient                 n                n            n           y
 volatile                  n                n            n           y
 native                    n                n            y           n
 synchronized              n                n            y           n

NOTE: enum is by default final.

-The modifiers which are applicable for inner classes but not applicable for outer classes are private, protected and static.
-The modifiers which are applicable for classes but not for enum are final and abstract.
-The modifiers which are applicable only for methods and which we cannot use anywhere else are native and synchronized.
-The only modifiers which are applicable for constructors are public, private, protected and default.
-The only applicable modifiers for local variable is final.

-The interface which is declared inside a class is always static whether we're declaring it or not.
-The interface which is declared inside interface is always public and static.
-The class which is declared inside interface is always public and static whether we're declaring it or not.

CLASS-LEVEL MODIFIERS:
-If the class is public it can be accessible from anywhere.
-If the class is abstract we cannot create the instance of that class.
-If the class is final then the child class creation is not possible.

public:
-If the class is declared as public we can access this class anywhere (no restrictions).

default:
-If the class is declared as default we can only use that that class within that package. We cannot access it from outside the package.


MEMBER ACCESS MODIFIERS:
public:
-We can use public methods or public variables from anywhere from same class or other class from same package or different package.
-If a member is public we can access that member but class should be visible otherwise we cannot access that variable.

default:
-If a member is default we can only access that method or variable within that package only. It is called package-level specifier.

private:
-If a member is private we can access that method or variable only in that class. It is also called class -level modifier.
-Private method cannot be accessed outside the class.
-Highly recommended modifier for variables is private so that data cannot be accessed from outside.
-We cannot override private method.

protected:
-If a variable or method is protected then it should be used in current package like default and also in their child classes.
-If we try to access protected method or variable from child class which is in different package then the reference should be of child class only not parent class.
 But if it is in same package then there is no problem at all.
-Protected member outside package we can access only in child class. We can access in same package anywhere but compulsory child reference should be there in child class.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

FLOW CONTROL:
-Flow control decscribes the order in which that statement will be executed at runtime.

Types:
1.Selection Statement (if-else, switch):
  i.if-else:
   -Syntax:
    if(b) {
       //action if b is true
    } else {
       //action if b is false
    }
   
  -The argument of the if statement should be of boolean type. By mistake if we're trying to provide any other type of data then we'll get compile time error.
  -else part and curly braces are optional. Without curly braces only one statement is allowed under if which should not be declarative statement.
  NOTE:- semicolon is a valid java statement which is also known as empty statement. This is no dangling else problem in Java. Every else is mapped to the
         nearest if statement.

  ii.switch
    -If several options are available then it is not recommended to use nested if-else because it reduces readability and increase complexity. To handle this kind
     of requirement we should go for switch statement.
    -The allowed arguments for switch statement are byte, short, char, int, until 1.4 version. But from 1.5 onwards corresponding wrapper classes and enum types are
     allowed. From 1.7 version onwards String types are also allowed.
    -Curly braces are manadatory except switch curly braces are optional.
    -Both case and default are optional i.e., an empty switch statement is a valid java syntax.
    -Inside a switch every statement should be under some case or default i.e., independent statements are not allowed inside switch otherwise we'll compile time error.
    -Every case label should be compile time constant i.e., constant expression. Final variable can be used as case constant.
    -If we declare any variable as final then we can use it as case constant inside switch.
    -Both switch argument and case labels can be expressions but case label should be constant expression. 
    -Every case label should be in the range of switch argument type otherwise we'll compile-time error.
    -Duplicate case labels are not allowed otherwise we'll get compile-time error.

    Case Label:
    -It should be constant expression.
    -The value should be in the range of switch argument type.
    -Duplicate case labels are not allowed.

2.Iterative Statement (while, do-while, for, forEach)
  i.while-loop:
    -If we don't know no.of iterations in advance then we'll go for while loop.
3.Transfer Statement (break, return, continue, try-catch, assertion)
  i.break:
    -We can use break statement in the following places:
     a.Inside switch to stop fall through
     b.Inside loops
       -To break loop execution based on some conditions.
     c.Inside labelled block to break block execution.
       e.g.   psvm(String[] args) {
                 int x = 10;
                 
                 l1:
                 {
                    sop("begin");
                    if(x == 10)
                      break l1;    //when we write break l1, it will come out of l1 label
                    sop("end");
                 }

                 sop("hello");
              }
       -These are the only places where we can use the break statement if we're using anywhere else then we'll get compile-time error.

  ii.continue
    -We can use continue statement inside loop to skip current iteration and continue for the next iteration.
    -We can use continue statement only inside loops. If we're trying to use anywhere else we'll get compile-time error saying continue outside loop.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
OOPS:
Module-1 (Security)
1.Data Hiding
2.Abstraction
3.Encapsulation
4.Tightly Encapsulated

Inheritance Category
5.Is-A Relationship
6.Has-A relationship
7.Method Signature

Polymorphism Related
8.Overloading
9.Overriding

10.Static Control flow
11.Instance control flow
12.Constructor
13.Coupling
14.Cohesion
15.Type Casting

DATA HIDING:
-Hiding of the data from accessing unauthorized source or outside people. Outside person cannot access our internal data directly or our internal data should not go out
 directly. This oops feature is nothing but data hiding.
-After validation or authentication outside person can access our internal data. For e.g. after providing proper username and password we will able to access our gmail,
 accout information.
 e.g. Even though we're valid customer of the bank, we will able to access our account information and we cannot access other's account information.
-By declaring data member(variables) as private we can achieve data hiding.
 e.g.  public class Account {
	
	private int salary;

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}
	
	public int getSalary() {
		//validation
		return salary;
	}
	
       }

-The main advantage is security.
 NOTE:- It is highly recommended to declare data members as private.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ABSTRACTION:
-Hiding internal implementations and just highlight set of services what we're offering is a concept of abstraction.
 e.g. Through a bank ATM gui screen bank people are highlighting the set of services what they're offering without highlighting internal implementations.

Advantage:
1.Security: As nobody can see it's implementation.
2.We can achieve security we're not highlighting our internal implementations.
3.Without affecting outside person, we will able to perform any type of changes in our system and hence enhancement will become easy.
4.It improves easiness to use our system.

How to implement?
-By using interface and abstract class we can implement abstraction.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
INTERFACE:
-Every service requirement specification is known as Interface.
-The contract between client and service provider is known as interface.
-100% pure abstract class we can say is interface.

Summary defn:
-Any service requirement specification or any contract between client and service provider or 100% pure abstract class is nothing but interface.

-Every method in the interface is by default public and abstract whether we're declaring or not.
 Why public?
 -To make the method available to every implementation class whether it is in same package or not.

 Why abstract?
 -Beacuse implementation class is responsible to provide implementation. We don't have to provide implementation inside the interface.

NOTE: abstract method cannot use the following modifiers:
      1.static
      2.final
      3.synchronized
      4.strictfp
      5.native

Interface Variables:
-An interface can contain variables.
-The main purpose of interface variables is to define requirement specification constants.
-Every interface variable is by default public, static and final.
 Why public?
 -To make the variable available to every implementation class whether it is in same package or not.

 Why static?
 -Without existing object also implementation class has to access this variable using Interface name.

 Why final?
 -If one implementation class changes value then remaining implementation class will be affected.
  To restrict this every interface variable is always final.

NOTE: For interface variables following keywords are not applicable:
      1.protected
      2.private
      3.transient
      4.volatile

NOTE: For final-static variable, compulsory we should perform initialization before class loading completion.
      -Means either initialize at the time of declaration or inside static block.
      -But static block concept not applicable to interface so we have to initialize the variables at the time of declaration only
       inside interface.
      For final-static variable, JVM won't provide any default value, compulsory we should provide initialization explicity.

CASE 1: If two interface contains a method with same signature and same return type then in the implementation class we have to provide implementation
        for only one method.

CASE 2: If two interfaces contains a method with a same name but different argument types then in the implementation class we have to provide
        implementation for both methods and these methods acts as overloaded methods inside implementation class.

CASE 3: If two interfaces contains a method with a same signature but different return types then it is impossible to implement both interfaces
        simultaneously. (If return types are not co-variant).

Interface Variable naming conflicts:
-Two interfaces can contain a variable with a same name and there may be a chance of variable naming conflicts but we can solve this problem by using
 interface names.

Marker Interface:
-If an interface doesn't contain any methods and by implementing that interface if our object will get some ability then that interface is called
 Marker Interface or Ability Interface or Tag Interface.
 E.g. 1. Serializable
         -If we want to save the object to the file or send on some network then compulsory the corresponding class should implement Serializable interface.
      2. Cloneable
         -By implementing Cloneable interface our objects are in position to produce exactly duplicate cloned objects.
      3. RandomAccess
      4. SingleThreadModel

Q.Without having any methods how the objects will get some ability in Marker Interfaces?
  -Internally JVM is responsible to provide the required ability to reduce complexity of the programming and make Java simple.

Q.Is it possible to create our own marker interface?
  -Yes, but customization of JVM is required. 

Adapter Classes:
-It is a simple java class that implements an interface with only empty implementation.
-If we implement an interface for each and every method of that interface compulsory we should provide implementation whether it is reqd or not. The problem in this
 approach is that it increases length of the code and reduces readability. We can solve this problem by using adapter classes.
-Instead of implementing interface if we extend adapter class we have to provide implementation only for required methods and we're not repsonsible to provide implementation
 for each and every method of the interface. So that length of the code will be reduced.

INTERFACE VS ABSTRACT CLASS VS CONCRETE CLASS:
-If we don't know anything about implementation just we have requirement specification then we should go for interface.
 e.g. Servlet interface

-If we're talking about implementation but not completely(partial implementation) then we should go for abstract class.
 e.g. GenericServlet, HttpServlet

-If we're talking about implementation completely and ready to provide service then we should go for Concrete class.
 e.g. MyOwnServlet

DIFFERENCES BETWEEN INTERFACE AND ABSTRACT CLASS:
Interface:
1.If we don't know anything about implementation and just we have requirement specification then go for interface
2.Inside interface every method is public and abstract whether we're declaring it or not. Hence interface is 100% pure abstract class.
3.As every interface method is always public and abstract and hence we can't declare with the following modifiers:
  private, protected, final, static, synchronized, native and strictfp.
4.Every variable in interface is always public, static and final whether we're declaring or not.
5.As every interface variable is always public, static and final we can't declare with following modifiers:
  private, protected, volatile and transient.
6.For interface variables compulsory we should perform initialization at the time of declaration only otherwise we'll
  get compile-time error.
7.static and instance blocks not allowed.
8.Constructor concept not applicable.

Abstract class:
1.If we're talking about implementation but not completely(partial implementation) then go for abstract class.
2.Every method present need not be public and abstract and we can take concrete methods also.
3.There are no restrictions on abstract class method modifiers.
4.Every variable present need not be public, static and final.
5.There are no restricitons on abstract class variable modifiers.
6.For abstract class variables we're not required to perform initialization at the time of declaration.
7.We can declare static and instance blocks inside abstract class.
8.We can declare constructor.

Q.What is the need of constructor inside abstract class?
-Anyway we can't create object for abstract class but abstract class can contain constructor.
-Abstract class constructor will be executed whenever we're creating child class object(for child object initialization only).
 Some properties may be inherited from parent.

NOTE: 1.Either directly or indirectly we can't create object for abstract class.

Q.Anyway we can't create objects for abstract class and interface but abstract class can contain constructor but interface doesn't contain constructor, what is the reason?
-The main purpose of constructor is to perform initialization of instance variables.
 Abstract class can contain instance variables which are required for child object.
 To perform initialization of those instance variables constructor is required for abstract class.
 
 But every variable present inside interface is always public, static and final whether we're declaring or not and there is no chance of existing instance variable inside
 interface. Hence, constructor concept is not required for interface.
 
 Whenever we're creating child class object, parent constructor will be executed(for the child object purpose only) but parent object won't be created.

Q.Inside interface every method is always abstract and we can take only abstract methods in abstract class also then what is the difference between interface and abstract class in this case
 i.e., Is it possible to replace interface with abstract class?
  Answer:
  -We can replace interface with abstract class but it is not a good programming practice. This is something like recruiting IAS officer for sweeping activity.
   If everything is abstract then it is highly recommended to go for interface but not for abstract class.

   abstract class X {                                        interface X {
 
   }							     }

   class Test extends X {                                    class Test implements X {

   }							     }

   1.While extending abstract class it is not	  	     1.While implementing interface we can extend some
     possible to extend any other class and		       other class and hence we won't miss any inheritance
     hence we're missing inheritance benefit.		       benefit.

   2.In this case object creation is costly.		     2.In this case object creation is not costly.
     e.g. Test t = new Test(); (2 mins)                        Test t = new Test(); (2 secs)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ENCAPSULATION:
-The process of binding data members and corresponding methods into a single unit is nothing but encapsulation.
-Every class in java is example of encapsulation.
-Encapsulation = data hiding + abstraction.

Advantage:
-We can achieve security.
-Enhancement will become easy.
-It improves maintainability of the application.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
TIGHTLY ENCAPSULATED:
-A class is said to be tightly encapsulated if and only if each and every variable is declared as private.
-Whether class contains corresponding getters and setters method or not and whether these methods are declared as public or not, these things we're not required to check.
NOTE: If the parent class is not tightly encapsulated then the child class will not be tightly encapsulated.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

INHERITANCE (IS-A Relationship):
-Inheritance is the mechanism to inherit all the parent class property into child class.

-By using extends keyword we can implement is-a relationship.

Conclusion:
1.Whatever method parent has by default available to child, in the case of inheritance; and hence on the child reference, we can call both the parent and the child method. 
2.Whatever child class has by default not available to parent, hence on the parent reference, we can not call child specific method.
3.Parent reference can be used to hold child object, but the child reference can't be used to hold parent object and we can not call child specific methods. 
  But, we can call the methods present in parent class. 
4.Parent reference CAN BE used to hold child object but child reference can not be used to hold parent object.
5.The most common method which are applicable for any type of child we have to define in parent class.
6.The specific methods which are applicable for a particular child we have to define in child class.
7.Total java api's is implemented based on inheritance concept.
8.The most common method which are applicable for any java objects are defined in Object class and hence every class in java is a child class of Object either directly or indirectly so
  that Object class methods by default are available to every java classes without re-writing. Due to this Object class acts as root for all java classes.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

MULTIPLE INHERITANCE:
-A java class cannot extend more than one class at a time hence java won't provide support for multiple inheritance w.r.t class.
NOTE: If our class does not extend any other java class then only our class is direct child of Object class.
      If our class extends any other class then our class is indirect child of Object class.

NOTE: Either directly or indirectly java won't provide support for multiple inheritance w.r.t classes.

Q.Why java won't provide support for multiple inheritance?
  -There may be chance of ambiguity problem hence java won't provide support for multiple inheritance.

-We can implement more than one interface in class but we can extend only one class.
-We can extend class and implement interface at same time but we have to write extends first and then implmements after.


-Interface can extend as many interfaces they want.
-Eventhough multiple method declarations are available in interface but implementation is unique hence there is a no chance of ambiguity.
-Through interface whatever we get is not inheritance.

NOTE: Cyclic inheritance is not possible in java it gives compilation error.
      public class A extends A {   //compile-time error

      }
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

HAS-A Relationship:
-It is also known as composition or aggregation.
-There is no specific keywords to implement has-a relation. But, most of the time we're depending on new keyword.
-The main advantage of has-a relationship is reusability of the code.
 e.g.  class Engine {
         .....
       }

       class Car {
         Engine e = new Engine();
       }

NOTE: In composition objects are strongly associated whereas in aggregation objects are weakly associated.

DIFFERENCE BETWEEN IS-A RELATIONSHIP AND HAS-A RELATIONSHIP:
is-a relationship:
-If we want total functionality of class then automatically we should go for is-a relationship.

has-a relationship:
-If we want part of functionality then we should go for has-a relationship.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

METHOD SIGNATURE:
-In java method signature consists of method name followed by arguments.
 e.g. public static int m1(int i, float f)
      In the above example m1(int i, float f) is the method signature.
-return type is not a part of method signature in java.
-Compiler will use method signature to resolve method class.
-Within a class two methods with same signature is not allowed.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------

METHOD OVERLOADING:
-When the methods are having same name but different parameters or different argument types is called method overloading.

Advantages:
-Flexibility to programmer.
-Reduce complexity.

-In method overloading, method resolution is taken care by compiler based on reference type i.e., overloading is known as static polymorphism/early binding/compile-time
 polymorphism.

CASE 1: public class Overloading {

	public static void main(String[] args) {
		Overloading ovr = new Overloading();
		ovr.m1();
		ovr.m1('a');
		ovr.m1("Sarthak");
	}
	
	public void m1() {
		System.out.println("no args");
	}
	
	public void m1(int a) {
		System.out.println("int - args");
	}
	
	public void m1(String s) {
		System.out.println("String-args");
	}

      }

-In overloading if exact type method is not available then compiler does not throw the compile-time error immediately, first compiler will promote 
 the data to the next level.

CASE 2:  public class Overloading {

	public static void main(String[] args) {
		Overloading ovr = new Overloading();
		ovr.m1(new Object());  //object-type
		ovr.m1("Sarthak");  //String-type
		ovr.m1(null);   //String-type
	}
	
	public void m1(Object a) {
		System.out.println("Object type");
	}
	
	public void m1(String s) {
		System.out.println("String type");
	}

      }

-In case of object types as arguments child class method get the first priority and the priority goes from bottom to top towards parents.
-In this case child will be called.

CASE 3:  public class Overloading {

	public static void main(String[] args) {
		Overloading ovr = new Overloading();
		ovr.m1(new StringBuffer());  //StringBuffer-type
		ovr.m1("Sarthak");  //String-type
		ovr.m1(null);   //ambiguity error since StringBuffer and String are at the same level.
	}
	
	public void m1(StringBuffer s2) {
		System.out.println("StringBuffer-type");
	}
	
	public void m1(String s1) {
		System.out.println("String-type");
	}

      }

CASE 4:  public class Overloading {

	public static void main(String[] args) {
		Overloading ovr = new Overloading();
		ovr.m1();  //var-args method
		ovr.m1(10,20);  //var-args method
		ovr.m1(10);   //general method
	}
	
	public void m1(int i) {
		System.out.println("general method");
	}
	
	public void m1(int... i) {
		System.out.println("var-args method");
	}

      }

-General method comes from first version of java. Whenever there is fighting between old and new concept please make sure old concept in java will win.
-var-args method always get the least priority.

CASE 5: public class Overloading {

	public static void main(String[] args) {
		Overloading ovr = new Overloading();
		ovr.m1(10, 20.5f);  //int-float
		ovr.m1(10.5f, 20);  //float-int 
		ovr.m1(10, 20);  //ambiguity error
                ovr.m1(10.5f, 20.5f) //no matching call
                
	}
	
	public void m1(int i, float f) {
		System.out.println("int-float");
	}
	
	public void m1(float f, int i) {
		System.out.println("float-int");
	}

      }

CASE 6:  
-In Overloading method resolution is done by compiler at compile time or taken care by compiler.
      
public class OverloadingCase6 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		OverloadingCase6 ovr = new OverloadingCase6();
		
		Animal a = new Animal();
		ovr.m1(a);     //Animal Version
		
		Monkey m = new Monkey();
		ovr.m1(m);    //Monkey Version
		
		Animal a1 = new Monkey();
		ovr.m1(a1);  //Animal Version because compiler binds the method call at compile time only.
		
	}

	public void m1(Animal a) {
		System.out.println("Animal Version");
	}
	
	public void m1(Monkey m) {
		System.out.println("Monkey Version");
	}
	
}

class Animal {
	
}

class Monkey extends Animal {
	
}

-In overloading compiler checks for only reference as whose reference is used to call the overloaded method it does not check whose object is gonna be created at runtime.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

METHOD OVERRIDING:
-If subclass has the same method as super class then it is called method overriding.

public class Test {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Parent p = new Parent();
		p.marry();  //Deepika
		
		Child c = new Child();
		c.marry();  //Alia
		
		Parent p1 = new Child();  //At compile time compiler will check whether marry() is available in Parent class or not and at runtime it will check whether
                                           //it is available in Child class or not, if not available in Child class then it will call Parent class method.    
		p1.marry();  //Alia
	}

}

class Parent {
	public void property() {
		System.out.println("cash + gold + loan");
	}
	
	public void marry() {
		System.out.println("Deepika");
	}
}

class Child extends Parent {
	public void marry() {
		System.out.println("Alia");
	}
}

-Method Overriding is also known as runtime polymorphism / dynamic binding / late binding.
-The parent class method which is overriden method and the child class method is known as overriding method.
-In overriding method resolution is always taken care by JVM based on runtime object and hence overriding is also considered as runtime polymorphism.

RULES FOR OVERRIDING:
RULE 1: 

class Parent {
	public void property() {
		System.out.println("cash + gold + loan");
	}
	
	public void marry() {
		System.out.println("Deepika");
	}
}

class Child extends Parent {
	public int marry() {   //compilation error
		System.out.println("Alia");
	}
}

-In method overriding method return type must be same till 1.4 version but after 1.4 version co-variant return type is being implemented.
Co-Variant return type:
-Child method return type need not to be same as parent method. It's child type also allowed. Such type of return type is called co-variant return type.
e.g.
class Parent {
	public void property() {
		System.out.println("cash + gold + loan");
	}
	
	public Object marry() {
		System.out.println("Deepika");
		return null;
	}
}

class Child extends Parent {
	public String marry() {
		System.out.println("Alia");
		return null;
	}
}

Parent method Return type                    		Valid Child method return type
  Object                             Object / String / StringBuffer / StringBuilder / Throwable / Child classes of Object
  Number                             Byte / Short / Integer / Long / Float / Double

NOTE: Co-variant return type is valid only for Object / Classes not for primitive type.

RULE 2:
class Parent {
	public void property() {
		System.out.println("cash + gold + loan");
	}
	
	public Object marry() {
		System.out.println("Deepika");
		return null;
	}
}

class Child extends Parent {
	public String marry() {
		System.out.println("Alia");
		return null;
	}
}
--------------------------------------------------------------------
class Parent {
	public void property() {
		System.out.println("cash + gold + loan");
	}
	
	Object marry() {          //default scope
		System.out.println("Deepika");
		return null;
	}
}

class Child extends Parent {
	public String marry() {   //public scope > default scope
		System.out.println("Alia");
		return null;
	}
}
--------------------------------------------------------------------
class Parent {
	public void property() {
		System.out.println("cash + gold + loan");
	}
	
	Object marry() {          //default scope
		System.out.println("Deepika");
		return null;
	}
}

class Child extends Parent {
	protected String marry() {   //protected scope > default scope
		System.out.println("Alia");
		return null;
	}
}

-Parent class private method is not available to the child class hence overriding of private method is not possible.
-Overriding is not possible for final method.
-We cannot override parent class final method in child class.
-If we're trying to override we'll get compile-time error.
-If the child class method is final still we cannot overide the method in the child of child class.
-If parent class method is declared as final then there is no chance to override that method.
e.g.
class Parent {
	
	public final void marry() { 
		System.out.println("Deepika");
	}
}

class Child extends Parent {
	public final void marry() {       //compile-time error, final method cannnot be overriden
		System.out.println("Alia");
	}
}

Parent Method     final                          Non-final              public         protected                   default               private
                    |                                |                    |                |                          |                     |
                    |  Compilation Error             |  OK                |                |                          |                     |
                    |                                |                    |                |                          |                     |
Child Method   final / non-final                 final / non-final      public       protected / public    default/protected/public     No resolution

-We cannot reduce the scope of access specifier while overriding.
-Parent class abstract method we should override in child class to provide implementation.

RULE 3:
-While overriding, we cannot reduce the scope of method but we can increase the scope. If same scope then no problem in overriding.

SCOPE HIERARCHY:
private < default < protected < public.

NOTE: We cannot create an object of abstract class.
      We can override non-abstract method as abstract but child class(this child class have to be declared as abstract then) of that child class is responsible to 
      provide implementation.

RULE 4:
                                                                    Throwable
                                                ________________________|_____________________________________________
                                               |                                                                      |
                                           Exception                                                                Error
          _____________________________________|_______________________________________
         |                           |                              |                  |
    RuntimeException            IOException                   SQLException    InterruptedException
     |-ArithmeticException       |-FileNotFoundException
     |-NullPointerException      |-EOFException
     |-ClassCastException

-Error and it's child classes and RuntimeException and it's child classes are unchecked exception and all other exceptions are checked exceptions.

NOTE: If child class method throws any checked exception, compulsory parent class method should throw the same checked exception or its parent otherwise we'll get compile
      time error. But there are no restrictions for unchecked exceptions.

e.g. 
class Parent {
	
	public void marry() throws IOException{ 
		System.out.println("Deepika");
	}
}

class Child extends Parent {
	public void marry() throws EOFException{
		System.out.println("Alia");
	}
}
-----------------------------------------------------------------
class Parent {
	
	public void marry() throws Exception{ 
		System.out.println("Deepika");
	}
}

class Child extends Parent {
	public void marry() throws EOFException{
		System.out.println("Alia");
	}
}

1. Parent: public void m1() throws Exception
   Child: public void m1()                        //valid

2. Parent: public void m1()
   Child: public void m1() throws Exception     //invalid

3. Parent: public void m1() throws Exception
   Child: public void m1() throws IOException   //valid

4. Parent: public void m1() throws IOException
   Child: public void m1() throws FileNotFoundException, EOFException   //valid

5. Parent: public void m1() throws IOException
   Child: public void m1() throws FileNotFoundException, InterruptedException  //invalid

6. Parent: public void m1() throws IOException
   Child: public void m1() throws AE, NPE, CC       //valid, AE, NPE, CC are not child of IOException but AE, NPE, CC are unchecked exceptions.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

OVERRIDING WITH RESPECT TO STATIC METHODS:
-We cannot override a static method as non-static we'll get compile time error.
 e.g.  
class Parent {
	
	public static void marry(){ 
		System.out.println("Deepika");
	}
}

class Child extends Parent { 
	public void marry(){                        //compile time error, The instance method cannot override the static method form Parent.
		System.out.println("Alia");
	}
}
------------------------------------------------------------
class Parent {
	
	public void marry(){ 
		System.out.println("Deepika");
	}
}

class Child extends Parent { 
	public static void marry(){                        //compile time error, The static method cannot hide the instance.
		System.out.println("Alia");
	}
}
-------------------------------------------------------------

-If both the parent and child class methods are static then we won't get any compile-time error. It seems overriding concept applicable for static methods but it is
 not overriding but it is method hiding.

METHOD HIDING:
-All rules of method hiding is exactly same as overriding except the following differences:

             Method Hiding                                           Method Overriding
1.Both parent and child class method should              1.Both parent and child class method should
  be static.                                               should not be static.
2.Compiler is responsible for method resolution          2.JVM is always responsible for method resolution
  based on reference type.                                 based on runtime object.

e.g.  
public class MethodHiding {

	public static void main(String[] args) {
		P p = new P();
		p.marry();      //Parent
		
		C c = new C();
		c.marry();     //Child
		
		P p1 = new C();
		p1.marry();   //Parent, Since overriding is not applicable therefore resolution is done by compiler.
	}

}

class P {
	
	public static void marry(){ 
		System.out.println("Parent");
	}
}

class C extends P { 
	public static void marry(){
		System.out.println("Child");
	}
}

-If both parent and child methods are non-static then it will become overriding, then the o/p will be :- Parent Child Child.

-----------------------------------------------------------------------------------------------------------------------------------------------------------
OVERRIDING W.R.T VAR-ARGS METHODS:
-We can override var-args method with another var-args method only but if we're trying to override with normal method then it will become overloading for child class not overriding.
e.g.
public class OverridingWithVarArgs {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		P p = new P();
		p.m1();   //Parent
		p.m1(10);  //Parent
		
		C c = new C();
		c.m1();  //Parent
		c.m1(10);  //Child
		
		P p1 = new C();
		p1.m1();  //Parent
		p1.m1(10);  //Parent
	}

}

class P {
	public void m1(int... x) {
		System.out.println("Parent");
	}
}

class C extends P {
	public void m1(int x) {
		System.out.println("Child");
	}
}

-In the above method if we replace child method with var-args method then it will become overriding.
e.g.
public class OverridingWithVarArgs {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		P p = new P();
		p.m1();   //Parent
		p.m1(10);  //Parent
		
		C c = new C();
		c.m1();  //Child
		c.m1(10);  //Child
		
		P p1 = new C();
		p1.m1();  //Child
		p1.m1(10);  //Child
	}

}

class P {
	public void m1(int... x) {
		System.out.println("Parent");
	}
}

class C extends P {
	public void m1(int... x) {
		System.out.println("Child");
	}
}
----------------------------------------------------------------------------------------------------------------------------------------------------------

OVERRIDING W.R.T VARIABLES:
-Variables resolution is always taken care by compiler based on reference type irrespective of whether the variable is static or non-static (overriding concepts
 are applicable only for methods but not for variables).
e.g.
public class OverridingWithVariables {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		P p = new P();
		sop(p.x);  //888
		
		C c = new C();
		sop(c.x);  //999
		
		P p1 = new C();
		sop(p1.x);  //888
	}

}

class P {
	int x = 888;
}

class C extends P {
	int x = 999;
}

NOTE:
Talking about variables:
If parent is non static and child is non static: Same Output
if parent is static and child non static: Same output
PArent is non static and child is static: Same Output
Both Static: Same output.

Q.What is the difference between Overloading and Overriding?

   Property                                           Overloading                                    Overriding
1.Method name                                            Same						Same
2.Argument type           			Must be different, atleast order		Must be same, including order.
3.Method Signature              		Must be different   					Same
4.Return type					No Restriction					Same until 1.4, after that co-variant
                                                                                                return types allowed.
5.private, static, final methods		Can be overloaded				Cannot be overriden.
6.Access modifiers				No restrictions  				Cannot decrease, Either same or increase
7.throws clause					No restrictions				        If child class method throws any checked exception,
												then compulsory parent class method should throw 
												either same or parent.
8.Method Resolution				Always taken care by compiler, based on         Always taken care by JVM.
                                                reference type.
9.Also known as                                 Compile-time polymorphism/early binding/        Runtime Polymorphism/Dynamic Polymorphism/
                                                static polymorphism/static binding.             Late binding/Dynamic binding.

NOTE: In overloading, we have to check only method name(must be same) and argument type(must be different, atleast order). We're not reqd to check remaining 
      Things like return type, access modifier, etc. Only need to check name and parameters.
      But in overriding, everything we have to check like method name, return type, arg type, access modifier, throws clause.
		
---------------------------------------------------------------

STATIC CONTROL FLOW:
-Whenever we're executing a java class the following sequence of steps will be executed as the part of static control flow:
 1.Identification of static members from top to bottom.  (Step 1-6)
 2.Execution of static variable assignments and static block from top to bottom.  (Step 7-12)  		
 3.Execution of main method. (Step 13-15)
 e.g.
    public class Base {

	static int i = 10;                             //step 1 identification, step 7 assignment
	
	static {                                       //step 2 identification
		m1();                                      //step 8
		System.out.println("First static block");  //step 10 , step 15
	}
	
	public static void main(String[] args) {       //step 3 identification
		m1();     //step 13
		System.out.println("Main method");         //step 15 
	}
	
	public static void m1() {                      //step 4 identification
		System.out.println(j);                     //step 9  o/p:- 0  , step 14 o/p:- 20   //indirect read
	}
	
	static {                                       //step 5 identification
		System.out.println("Second static block"); //step 11
	}
	
	static int j = 20;                             //step 6 identification  //step 12 assignment

    }

Read Indirectly Write Only(RIWO):
-Inside static block if we're trying to read a variable that read operation is called Direct Read.
-If we're calling a method and within that method if we're trying to read that variable that read operation is called
 Indirect read.
-If a variable is just identified by the JVM and the original value are not yet assigned then the variable is said to be
 in Read Indirectly Write Only(RIWO) state.
-If a variable is in RIWO state then we cannot perform direct read but we can perform indirect read.
-If we're trying to read directly we'll compile time error. (Cannot reference a field before it is defined).

NOTE: When we're loading child class automatically parent class will be loaded. But whenever we're loading parent class
      child class won't be loaded. (Bcoz parent class members by default available to child class whereas child class members
      by default are not available to parent class).

STATIC BLOCK:
-Static block will be executed at the time of class loading. If we want to perform any activity we have to define all that
 inside static block.
-At the time of java class loading the corresponding native library should be loaded. We have to define this activity inside static block.

Q.Without writing main method is it possible to print at console?
 -No, from java 1.7 version onwards main method is mandatory to start the program execution. Hence from java 1.7 onwards we cannot
  run any java program without main method.

STATIC CONTROL FLOW IN PARENT-CHILD RELATIONSHIP:
-Whenever we're executing child class the following sequence will be executed automatically as a part of static control flow:
 1.Identification of static members from parent to child.
 2.Execution of static variable assignment and static block from parent to child.
 3.Execution of only child class main method.
 e.g.
    package com.oopsConcepts.staticControlFlow;

    public class Test1 {
	static int i = 10;  //step 1 identification, step 13 assignment
	
	static {       //step 2 identification
		m1();      //step 14
		System.out.println("Parent first static block");  //step 16
	}
	
	public static void main(String[] args) {   //step 3 identification
		m1();
		System.out.println("Base main method");
	}
	
	public static void m1() {    //step 4 identification
		System.out.println(j);   //step 15
	} 
	
	static {     //step 5 identification
		System.out.println("Base second static block");  //step 17
	}
	
	static int j = 20;    //step 6 identification. step 18 assignment
    }

    public class Test2 extends Test1 {
	
	static int x = 100;    //step 7 identification, step 19 assignment
	
	static {       //step 8 identification
		m2();      //step 20
		System.out.println("Child first static block");  //step 22
	}
	
	public static void main(String[] args) {  //step 9 identification
		m2();
		System.out.println("Child main method");
	}
	
	public static void m2() {    //step 10 identification
		System.out.println(y);   //step 21
	}
	
	static {      //step 11 identification
		System.out.println("Child second static block");  //step 23
	}
	
	static int y = 200;   //step 12 identification. step 24 assignment
    }

INSTANCE CONTROL FLOW:
-Whenever we're executing a java class first "static control flow will be executed". In the static control flow if we're creating the
 object following sequence of events will be executed as a part of instance control flow:
 1.Identification of instance member (variable, method, block) from top to bottom.
 2.Execution of instance variable assignments and instance block from top to bottom.
 3.Execution of constructor.
 e.g.
    public class Test1 {

	int i = 10;      //step 2 identification, step 8 assignment
	
	{              //step 3 identification
		m1();     //step 9
		System.out.println("First instance block");   //step 11
	}
	
	Test1() {     //step 4 identification
		System.out.println("Constructor");    //step 14
	}
	
	public static void main(String[] args) {
		Test1 t = new Test1();    //step 1
		System.out.println("Main method");   //step 15
	}

	public void m1() {     //step 5 identification
		System.out.println(j);    //step 10
	}
	
	{         //step 6 identification
		System.out.println("Second instance block");    //step 12
	}
	
	int j = 20;   //step 7 identification, step 13 assignment
    }

-Static control flow is "one time activity" which will be performed at the time of class loading but instance control flow is "not one
 time activity"	and it will be performed for every object creation.
-Object creation is the most costly operation. If there is no specific requirement then it is not recommended to create object. 

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

INSTANCE CONTROL FLOW IN PARENT-CHILD RELATIONSHIP:
-Whenever we're creating child class object the following sequence of events will be performed automatically as the part of instance
 control flow:
 1.Identification of instance member from Parent to Child.
 2.Execution of instance variable assignments and instance block only in parent class.
 3.Execution of Parent constructor.
 4.Execution of instance variable assignments and instance block in child class.
 5.Execution of Child constructor.
 e.g.
    public class Test2 {

	int i = 10;      //step 2 identification, step 14 assignment
	
	{              //step 3 identification
		m1();     //step 15
		System.out.println("Parent first instance block");   //step 17
	}
	
	Test2() {     //step 4 identification
		System.out.println("Parent Constructor");    //step 20
	}
	
	public static void main(String[] args) {
		Test2 t = new Test2(); 
		System.out.println("Parent main method");
	}

	public void m1() {     //step 5 identification
		System.out.println(j);    //step 16
	}
	
	{         //step 6 identification
		System.out.println("Parent second instance block");    //step 18
	}
	
	int j = 20;   //step 7 identification, step 19 assignment

   }

   public class Test3 extends Test2 {

	int x = 100;      //step 8 identification, step 21 assignment
	
	{              //step 9 identification
		m2();     //step 22
		System.out.println("Child first instance block");   //step 24
	}
	
	Test3() {     //step 10 identification
		System.out.println("Constructor");    //step 27
	}
	
	public static void main(String[] args) {
		Test3 t = new Test3();    //step 1
		System.out.println("Child main method");   //step 28
	}

	public void m2() {     //step 11 identification
		System.out.println(y);    //step 23
	}
	
	{         //step 12 identification
		System.out.println("Child second instance block");    //step 25
	}
	
	int y = 200;   //step 13 identification, step 26 assignment
   }

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

COMBINATION OF STATIC AND INSTANCE CONTROL FLOW:

 e.g.
    public class Test {

	{
		System.out.println("FIB");
	}
	
	static {
		System.out.println("FSB");
	}
	
	Test() {
		System.out.println("Constructor");
	}
	
	public static void main(String[] args) {
		Test t1 = new Test();
		System.out.println("main");
		Test t2 = new Test();
	}
	
	static {
		System.out.println("SSB");
	}
	
	{
		System.out.println("SIB");
	}

   }
 
   O/P :- 
		FSB
		SSB
		FIB
		SIB
		Constructor
		main
		FIB
		SIB
		Constructor

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

CONSTRUCTOR:
-Once we create an object or instance, compulsory we should perform initialization then only the object is in position to respond properly.
NOTE: Whenever we're creating an object some pieces of the code will be executed automatically to perform initialization of the object. This piece of
      code is nothing but constructor. Hence, the main purpose of constructor is to initialize the object.
-The main purpose of the constructor is to initialize the object but NOT to create the object.

 Difference between constructor and instance block?
 -The main purpose of the constructor is to initialize the object but other than initialization if we want to perform any activity for every object creation
  then we should go for instance block like updating one entry in database. For every object creation it will increment/add new value to the database.
 -Both constructor and instance block have their own purpose and replacing one concept with another may not work always.
 -Both constructor and instance block will be executed for every object creation.

-Constructor can be overloaded.
 e.g. 
     public class Test {
	
	static int count = 0;
	
	{
		count++;
	}
	
	Test() {
		System.out.println("default");
	}

	Test(int i) {
		System.out.println("int");
	}
	
	Test(double d) {
		System.out.println("double");
	}
	
	public static void main(String[] args) {
		Test t1 = new Test();
		Test t2 = new Test(10);
		Test t3 = new Test(10.5);
		System.out.println("The number of objects created " +count);
	}

    }

    O/P: default
         int
	 double
	 The number of objects created 3


RULES FOR WRITING CONSTRUCTOR:
-Name of the class and name of the constructor must be same.
-Return type concepts are not applicable for constructor even void also.
-By mistake if we're trying to declare return type for the constructor we won't get any compile time error bcoz compiler treats it as a method.
-Hence it is legal (stupid to have a method whose name is exactly same as class name).
-The only applicable access modifiers for constructor are public, private, protected and default. We'll get compile time error.

DEFAULT CONSTRUCTOR:
-Compiler is responsible to generate default constructor but NOT JVM.
-If we're not writing any constructor then only compiler will generate default constructor, i.e., if we're writing atleast one constructor, then compiler
 won't generate default constructor. Hence, every class in java can contain constructor. It may be default constructor generated by compiler or customized
 constructor explicitly provided by programmer, but not both simultaneously.

PROTOTYPE OF DEFAULT CONSTRUCTOR:
-It is always no-args constructor. The access modifier of default constructor is exactly same as access modifier of class.
-It contain only one line (super() method). It is no-args call to Superclass constructor.
-The first line inside every constructor will be either super() of this() and if we're not writing anything then compiler will always place super().

CASE 1: We can take super() or this() only in first line of constructor. If we're trying to take anywhere else we'll get compile-time error.

CASE 2: Within the constructor, we can either take super() or this(). We cannot take both simultaneously.

CASE 3: We can use super() or this() only inside constructor. If we're trying to use outside of constructor we'll get compile-time error.

            super() and this()                                                       super and this
1.These are constructor calls to call super class                   1.These are keywords to reference superclass and
  and current class constructor.                                      current class instance members.
2.We can only use in constructor as first line.                     2.We can use anywhere except static area.
3.We can use it only once in a constructor.                         3.We can use it any number of times.

OVERLOADED CONSTRUCTOR:
-Within a class we can declare multiple constructor and all this constructor have same name but different types of arguments or parameters. Hence all this
 constructors are called overloaded constructors. Hence overloading concept is also applicable for constructors.
-For constructor, inheritance and overriding concepts are not applicable but overloading concepts are applicable.
-Every class in java including abstract class can contain constructor but interface cannot contain constructor.

CASE 1: Recursive method call is a runtime exception saying "StackOverflowError".
        But in our program if there is a chance of recursive constructor invocation then the code won't compile and we'll get compile-time error.
        e.g.
        public class Test1 {
	
	public void m1() {
		m2();
		System.out.println("m1 method");            //Runtime Exception
	}

	public void m2() {
		m1();
		System.out.println("m2 method");
	}
	
	Test() {
		this(10);               //Compile-time error
	}
	
	Test(int i) {
		this();
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

      }

CASE 2: If parent class contain any argument constructor then while writing child class we have to take special care w.r.t constructor. Whenever we're writing any argument
        constructor it is highly recommended to write default constructor also.
        e.g. 
            class P {
	
//	P() {
//		
//	}
	
	P(int i) {
		System.out.println("Parent parameterized constructor");
	}
     }

     class C extends P {
	C() {
		super();            //compile time error
	}
     }

NOTE: If parent class constructor throws any checked exception compulsory child class constructor should throw same checked exception or it's parent otherwise code will
      not compile.

Q.The main purpose of constructor is to create object -- False
Q.The main purpose of constructor is to initialize to object -- True
Q.The constructor name should be same as class name -- True
Q.The constructor name need not be same as class name -- False
Q.Return type applicable for constructor but void only -- False
Q.We can apply any modifier on constructor -- False
Q.Default constructor is generated by JVM -- False
Q.Compiler is responsible for generating default constructor -- False
Q.Compiler will always generate default constructor -- False (If there is no any constructor the compiler will generate)
Q.If we're not writing no-args constructor then compiler will generate default constructor -- False
Q.Every no-args constructor is always default constructor -- False
Q.Default constructor is always no-args constructor -- True
Q.The first line in every constructor is either super() or this() but if we're not writing anything then compiler will generate this() -- False (Compiler generates super())
Q.For constructor both overloading and overriding concepts applicable -- False
Q.For constructor inheritance applicable but not overriding -- False
Q.Interface can contain constructor -- False
Q.Recursive constructor invocation is a run-time exception -- False
Q.If a parent class constructor throws some checked exception compulsory child class constructor should throw same checked exception or its child -- False
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TYPECASTING:
-We can use parent reference to hold child object.
 e.g. Object o = new String("Sarthak");
-We can use interface reference to hold it's implementation class object.
 e.g. Runnable r = new Thread();

 e.g.
 A b = (c) d;
 
 A - class/ interface
 b - Name of reference
 c - class/interface
 d - reference variable name

 Rules:
 1.(Complite-time checking)
   The type of d and c must have some relation either child to parent or parent to child (or same type) otherwise we'll compile-time error saying inconvertible
   type found.
   StringBuffer sb = new StringBuffer("Sarthak");
   Object obj = (Object) sb;
   System.out.println(obj.getClass().getName());   //java.lang.StringBuffer

   String s = new String("Sarthak");
   StringBuffer sb = (StringBuffer) s;  //Compile-time error

 2. (Complite-time checking)
    c must be either same or derived type of A otherwise we'll get compile time error.
    Object o = new String("Sarthak");
    System.out.println(o.getClass().getName());  //java.lang.String
    StringBuffer sb = (String) o;  //compile-time error

 3. (Runtime Checking)
    Runtime object type of d must be either same or derived type of c otherwise we will get runtime exception saying ClassCastException.
    e.g.
       Object o = new Object();
       String s = (String) o;          //Runtime Exception :- ClassCastException

    NOTE: Runtime type of object means which type it is pointing to or which type is written after new keyowrd.
          Compile time type of object is the type of the reference which is used to point the object.

UPCASTING:
-Upcasting is a type of object typecasting in which a child object is typecasted to a parent class object.
-In Upcasting, we assign a parent class reference object to the child class.
-Upcasting is possible both implicitly and explicity.
 Implicit: Parent p = new Child();
 Explicit: Parent p = (Child) new Child();

-Upcasting will be done internally and due to upcasting the object is allowed to access only parent class members
 and child class specified members (overridden methods, etc.) but not all members.
-Also known as Generalization or Widening.
 e.g.
 Parent p = new Child();

DOWNCASTING:
-DownCasting is a type of object typecasting in which a parent object is typecasted to a child class object
-Downcasting cannot be implicit.
 Child c = new Parent();  //compile-time error
-We can forcefully cast a parent to a child which is known as downcasting. After we define this type of casting explicitly, 
 the compiler checks in the background if this type of casting is possible or not. If its not possible, 
 the compiler throws a ClassCastException. 
-DownCasting is possible in only one case:
 Upcasting will be done internally and due to upcasting the object is allowed to access only parent class members
 and child class specified members (overridden methods, etc.) but not all members.
 Due to DownCasting we'll be able to access the child specific properties.
 The following is the procedure:
 Parent p = new Child();
 Child c = (Child) p;

 Reference link of full article : https://www.geeksforgeeks.org/upcasting-vs-downcasting-in-java/

NOTE: Through typecasting we're not creating any new object for the existing object. We're providing another type of reference variable i.e., we're performing
      type-casting not object-casting.

    e.g. 1.String s = new String("Sarthak");
           Object o = (Object) s;

           Object obj = new String("Sarthak");

         2.Number n = new Short((short)10);
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

STRINGS:
-String is immutable.
-Once we create the String object we cannot change the value of it, therefore String is immutable or non-changeable. This non-changeable behaviour is called
 immutability.
-StringBuffer and StringBuilder are mutable.
-capacity() not required in String bcoz it is fixed so only length() is there.

CASE 1:
 e.g. 
           String s = new String("Sarthak ");
           s.concat("Shivgan");      //creates new string "Sarthak Shivgan" in heap.
	   System.out.println(s);    //Sarthak, since s points to "Sarthak" in heap.
 
           As there is no any variable assigned to concat then "Sarthak Shivgan" will go into garbage.

           String s = new String("Sarthak ");
           s = s.concat("Shivgan");  //Reference changes to "Sarthak Shivgan" in heap
	   System.out.println(s);    //Sarthak Shivgan

e.g.
    StringBuffer s = new StringBuffer("Sarthak ");
    s.append("Shivgan");
    System.out.println(s);   //Sarthak Shivgan
   
 As no new object is created this changeable behaviour is called mutability.

CASE 2: == operator and equals()
e.g.

		String s1 = new String("Sarthak");
		String s2 = new String("Sarthak");
		System.out.println(s1 == s2);    //false
		System.out.println(s1.equals(s2));   //true
		
		String s3 = "Sarthak";
		System.out.println(s3 == s2);   //false
		System.out.println(s3.equals(s2));  //true

== -> checks for reference
s1.equals(s2) -> checks for content/value

NOTE: String Constant Pool(SCP) is not applicable for StringBuffer and StringBuilder.

equals() method:
-equals() method is written inside Object class and the functionality of that method in Object class is to compare the two objects based on the reference only.

-equals() method in String class is overriden from the Object class and the functionality of that method inside String class is that it compares two Strings based
 on content only.

-equals() method is not present inside StringBuffer and since StringBuffer is child of Object class it inherits the equals() methods and compares the two strings
 based on reference only.

e.g.
		StringBuffer s1 = new StringBuffer("Sarthak");
		StringBuffer s2 = new StringBuffer("Sarthak");
		System.out.println(s1 == s2);  //false
		System.out.println(s1.equals(s2));  //false

----------------------------------------------------+--------------------------------------------------------+
                      Heap                          |                          SCP                           |
----------------------------------------------------+--------------------------------------------------------+
1.Whenever new operator is there compulsory new     |   1.Implicitly referenced by JVM for future purpose    |
  object is created in heap area with content.      |                                                        |
						    |	2.Until 1.6 version SCP was a part of method area.   |
                                                    |     But from 1.7 version SCP area is moved to heap     |
                                                    |     area.                                              |
----------------------------------------------------+--------------------------------------------------------+

e.g. String s = new String("Sarthak");  -- 2 objects created. 1 in heap and 1 in SCP.


String s = "Sarthak"  - 1 object created in SCP
First JVM will check any object with same content in SCP. If it is present then it will refer to that object and if not present then it will create new object in SCP.

e.g.
String s = new String("operative");
s.concat("media");
s = s.concat("pune");

How many object will be created ?
Ans:- 6

NOTE: For every literal used one copy will be created in SCP.

---------------------------------------------------------------------------------+
                Heap                  |                     SCP                  |
---------------------------------------------------------------------------------+
             operative                |                   operative              |
				      |					         | 
           operative media            |                    media                 |
				      |						 |
     s ---> operative pune            |                    pune                  |
---------------------------------------------------------------------------------+

In runtime operations if new object is created that object will be created in heap area (s.concat("media")).

e.g. String s = new String("spring");
     s.concat("fall");
     String s1 = s.concat("winter");
     s1.concat("summer");
     sop(s);   //spring
     sop(s1);  //springwinter

Q.How many objects will be created?
Ans:- 8

---------------------------------------------------------------------------------+
                Heap                  |                     SCP                  |
---------------------------------------------------------------------------------+
      s ---->  spring                 |                   spring                 |
				      |					         | 
           springfall                 |                    fall                  |
				      |						 |
     s1 ---> springwinter             |                    winter                |
				      |						 |
       springwintersummer             |                   summer                 |
---------------------------------------------------------------------------------+

e.g.
		String s1 = new String("you cannot change me");
		String s2  = new String("you can not change me");
		System.out.println(s1==s2);   //false
		
		String s3 = "you cannot change me";
		System.out.println(s1==s3);   //false
		
		String s4 = "you cannot change me";
		System.out.println(s3==s4);   //true
		
		String s5 = "you cannot " + "change me";   //If both the strings are constant then compiler will perform operation at compile time.
		System.out.println(s4==s5);  //true
		
		String s6 = "you cannot ";
		String s7 = s6 + "change me";  //At runtime if atleast one variable (bcoz variable value is resolved at runtime) is there in concatenation then the 
					       //new object(s7 here) will be created in heap.
		
		System.out.println(s4==s7);  //false
		
		final String s8 = "you cannot ";   //s8 becomes final and is resolved at compile time only.
		String s9 = s8 + "change me";     //here s8 is a variable here but since it is final therefore it is resolved by compiler at compile time
                                                  //therefore both the constants will be created inside SCP only.
		
		System.out.println(s9 == s8);  //false

ADVANTAGE OF SCP (String Constant Pool):
-In SCP area one object is used with many references, no new object will be created.
-Performance will be increased.
-Memory usage reduces.

WHY IMMUTABILITY USED IN STRING?
-If many references is pointing to same object and one person wants to change that then every other will be impacted. Therefore string immutability comes into picture.
 A new object will be created instead of modifying old one.

WHY SCP CONCEPT IS AVAILABLE ONLY FOR STRING NOT FOR STRINGBUFFER?
-Because String is most commonly used object therefore java people provide special facilities to String like SCP whereas StringBuffer is rarely used.

WHY STRING OBJECTS ARE IMMUTABLE WHEREAS STRINGBUFFER OBJECTS ARE MUTABLE?
-In case of a String because of SCP same object can be reused multiple times by using references i.e., immutability concepts are used so every time new object will be
 created if any reference is used to change the object.
-Reusing same object is not there in StringBuffer so it is not required in StringBuffer. For every reference new object is created.
-In addition to String object any other objects that are immutable in java are all wrapper classes objects because of reusing the same object.

IMPORTANT CONSTRUCTOR OF STRING CLASS:
1.String s = new String();
2.String s = new String(string_literals);
3.String s = new String(StringBuffer sb);
4.String s = new String(StringBuilder sbd);
5.String s = new String(char[] c);
6.String s = new String(Byte[] b);

IMPORTANT METHODS OF STRING:
1.charAt(int index)
2.concat(String s)
3.equals(String s)
4.equalIgnoreCase(String s)
5.isEmpty() -- consider whitespace as an character
6.isBlank() -- doesn't consider whitespace
7.length()
8.replace(char oldChar, char newChar) -- replaces all occurences of oldChar with newChar
9.trim() -- only removes all leading and trailing whitespaces but not from the middle of two words.

WHAT IS THE DIFFERENCE BETWEEN FINAL V/S IMMUTABILITY?
-If any reference variable is final you cannot assign it's reference to other whereas immutability talks about object but not for variable.
-------------------------------------------------------------------------------------------------------------------------------------------------------------

STRINGBUFFER:
-If the content is not fixed and change is made frequently then we can use StringBuffer.
-If we use String in case of frequent change in content then every time a new object will be created. As we know String is immutable and wastage of memory
 and performance problem.

IMPORTANT CONTRUCTORS OF STRINGBUFFER:
-By default capacity of StringBuffer is 16.
-As we know in StringBuffer we can append as many characters to string, so there is a capacity for StringBuffer object in java i.e., 16 by default.
 If any new character is added then it increases it's capacity using formula 2*(currentCapacity + 1).
-As we know default capacity is 16, so when we add 16 characters and print the capacity it gives 16, because default capacity is 16 and characters are also 16,
 but when we add 17th character and then print the capacity it will give 34, bcoz default is 16 we try to add 17th character, so it uses the formula 2*(currentCapacity + 1)
 and our capacity becomes 34.

e.g. StringBuffer sb = new StringBuffer("Sarthak");

1.StringBuffer sb = new StringBuffer();
2.StringBuffer sb = new StringBuffer(int initialCapacity);
3.StringBuffer sb = new StringBuffer(String s);

IMPORTANT METHODS FOR STRINGBUFFER:
1.public int length();
2.public int capacity();
3.public char charAt(int index);
4.public void setCharAt(int index, char newChar);
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------+
		STRINGBUFFER				   |			STRINGBUILDER				|
------------------------------------------------------------------------------------------------------------------------+
1.Every method present in StringBuffer is synchronized.    | 	1.No method present in StringBuilder is synchronized.   |
2.At a time only one thread is allowed to operate on       |    2.At a time multiple threads are allowed to operate on  |
  StringBuffer object and hence it is thread safe.         |      StringBuilder object hence it is not thread safe.     |
3.Threads are required to wait to operate on               |    3.Threads are not required to wait to operate on        |
  StringBuffer object hence performance is low.            |      StringBuilder object hence performance is high.       |
------------------------------------------------------------------------------------------------------------------------+

STRINGBUILDER:
-It is the replica of StringBuffer. The only difference is that all the methods of StringBuilder is not synchronized. Other than that every method, every constructor
 everything is same as StringBuffer.
-------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------------------------+
             STRING                                               STRINGBUFFER                                      STRINGBUILDER
----------------------------------------------------------------------------------------------------------------------------------------------------------
    When content is fixed,                            When content is not fixed, changing and             When content is not fixed, changing and
    not changing                                      thread safety is required. At a time only           thread safety is not required. At a time multiple
                                                      one thread operates.                                thread operates.
-----------------------------------------------------------------------------------------------------------------------------------------------------------
COLLECTIONS:
-Collections are growable in nature, i.e., based on our requirement we can increase/decrease the size.
-Collections can hold both homogenous and heterogenous elements or objects.
-Every collection class is implemented based on some standard data structure. Hence, for every requirements ready-made method support is available.
-Being a programmer we're responsible to use those methods and we're not responsible to implement those methods.

COLLECTION:
-If we want to represent a group of individual objects as a single entity then we use Collection.

COLLECTIONS FRAMEWORK:
-It contains several classes and interfaces which can be used to represent a group of individual object as a single entity.

Q.What is the difference between Collection and Collections?
  -Collection is an interface. If we want to represent a group of individual objects as a single entity then we should go for Collection.
  -Collections is an utility class which is present in java.util package which provides several utility methods for Collection objects(sorting, searching, etc.).

                                                                    Collection(I)
                    _____________________________________________________|____________________________________________________
		   |                                                     |                                                    |
                 List(I)					        Set(I)                                              Queue(I)
    _______________|______________                    ____________________|________________                         ___________|___________
   |               |              |                  |                                     |			   |                       |
ArrayList(C)    LinkedList(C)    Vector(C)        HashSet(C)                           SortedSet(I)           PriorityQueue            BlockingQueue
                                   |                 |                                     |
                                 Stack(C)        LinkedHashSet(C)                   NavigableSet(I)
                                                                                           |
                                                                                       TreeSet(C)


                                                                      Map(I) (1.2v mai aaya)
                       _________________________________________________|___________________________
                      |                   |               |                   |                     |
                   HashMap(1.2v)      WeakHashMap     IdentityHashMap      SortedMap(I)(1.2v)   Dictionary(legacy)
                      |                  (1.4)           (1.2v)               |                     |
                 LinkedHashMap                                          NavigableHashMap(I)     HashTable(legacy)
                     (1.4v)                                                   |
                                                                           TreeMap(C)(1.2v)

COLLECTION INTERFACE:
-If we want to represent a group of objects as a single entity then we should go for Collection.
-Collection interface defines most common methods which are applicable for any Collection object. In general, Collection interface is considered as a root
 interface of Collections.

List Interface:
-It is a child interface of Collection interface.
-If we want to reperesent a group of individual object as a single entity where duplicates are allowed and insertion order must be preserved.

NOTE: In 1.2v, Vector and Stack classes are re-engineered to implement List interface.

Set Interface:
-It is the child interface of Collection Interface.
-If we want to represent a group of individual object as a single entity where duplicates are not allowed insertion order not required then we'll go for
 Set interface.

SortedSet Interface:
-It is a child interface of Set Interface.
-If we want to represent a group of individual object as a single entity where duplicates are not allowed and all objects should be inserted according to
 some sorting order then we'll go for SortedSet interface.

NavigableSet Interface:
-It is a child interface of SortedSet Interface.
-It contains several methods for navigation purpose.

Queue Interface:
-It is the child interface of Collection Interface.
-If we want to represent a group of individual object prior to processing then we should go for Queue.
-Usually Queue follows FIFO but based on requirement we can implement or own priority order.
e.g. Before sending a mail, all mail id's we have to store in some data structure. The order in which we added email id's in the same order mails should be
     delivered.

NOTE: All the above interfaces(Collection, List , Set, SortedSet, NavigableSet and Queue) meant for representing a group of individual object. But if we want to 
      represent a group of objects as key-value pairs then we should go for Map interface.

Map Interface:
-It is not a child interface of Collection.
-If we want to represent a group of objects as key-value pairs, then we go for Map interface.
-Both key and value are objects only .
-Duplicate keys are not allowed but values can be duplicated.

SortedMap Interface:
-It is a child interface of Map.
-If we want to represent a group of key-value pair according to some sorting order of keys then we should go for SortedMap.
-In SortedMap the sorting should be based on keys but not based on values.

NavibagleMap Interface:
-It defines several methods for navigation purpose.
-------------------------------------------------------------------------------------------------------------------------------------------------------------

IMPORTANT METHODS OF COLLECTION INTERFACE:

1.boolean add(Object o);
2.boolean addAll(Collection c);
3.boolean remove(Object o);
4.boolean removeAll(Collection c);
5.boolean retainAll(Collection c);
6.boolean retain(Object o);
7.void clear();
8.boolean contains(Object o);
9.boolean containsAll(Collection c);
10.boolean isEmpty();
11.int size();

------------------------------------------------------------------------------------------------------------------------------------------------------------

LIST INTERFACE:
-We can preserve insertion order with index and we can differentiate duplicate objects by using index hence index will play very important role in list.

IMPORTANT METHODS OF LIST:

1.void add(int index, Object o);
2.boolean addAll(int index, Collection c);
3.Object get(int index);
4.Object remove(int index);
5.Object set(int index, Object new);  //returns old object which gets replaced.
6.int lastIndexOf(Object o);

ARRAYLIST:
-The underlying data structure is runnable/growable array.
-Duplicates are allowed.
-Insertion order is preserved.
-Heterogenous objects are allowed except TreeSet and TreeMap.
-null insertion is possible.

CONSTRCUTOR OF ARRAYLIST:
1.ArrayList l = new ArrayList();
  It creates empty ArrayList object with default initial capacity 10. Once ArrayList reaches it's max capacity then a new ArrayList object will be created
  with new capacity. new capacity = (currentCapacity * 3/2) + 1.

2.ArrayList l = new ArrayList(int initialCapacity);
  It creates an empty ArrayList object with specified intitial capacity.

3.ArrayList l = new ArrayList(Collection c);
  Creates an equivalent ArrayList object for the given collection.

-Usually we can use collection to hold and transfer object from one location to another location.
-To provide support for this requirement every collection class by default implements Serializable and Cloneable interface.

For Heterogenous elements - ArrayList al = new ArrayList();
For Homogenous elements - ArrayList<String> al = new ArrayList<String>();

RandomAccess Interface:
-ArrayList and Vector classes implements RandomAccess interface so that any random element we can access with the same speed.
-RandomAccess interface present in java.util package and it does not contain any method. It is a marker interface where required ability will be provided
 automatically by the JVM.

Q.What is marker interface?
  An interface which does not have any method.

Q.When to use ArrayList?
  ArrayList is the best choice if our frequent operation is retrieval operation. Because ArrayList implements RandomAccess interface.
  ArrayList is the worst choice if our frequent operation is insertion or deletion.

Q.What is the difference between ArrayList and Vector?
  ArrayList:
  -Every method present in ArrayList is non-synchronized.
  -At a time multiple threads are allowed to operate on ArrayList object and hence it is not thread safe.
  -Realtively performance is high because threads are not required to wait.
  -Introduced in 1.2v
  Vector:
  -Every method present in vector is synchronized.
  -At a time only one thread is allowed to operate on Vector object and hence it is thread safe.
  -Realtively performance is low because threads are required to wait.
  -Introduced in 1.0v

Q.How to get synchronized version of ArrayList?
  -By default Arraylist is non-sysnchronized but we can get synchronized ArrayList by using synchronizedList() of Collections utility class.
   Similarly we can get synchronized version of Set and Map object by using the following method:
   1.public static Set synchronizedSet(Set s);
   2.public static Map synchronizedMap(Map m);
-------------------------------------------------------------------------------------------------------------------------------------------------------------

LINKEDLIST:
-The underlying data structure is Doubly Linked List.
-Insertion order is preserved.
-Duplicate elements are allowed.
-null insertion is possible.
-LinkedList implements Serializable and Cloneable interface but not RandomAccess interface.
-Is best if our frequent operation is insertion or deletion in middle.
-LinkedList is the worst choice if our frequent operation is retrieval.

CONSTRUCTORS OF LINKEDLIST:
1.Linked ll = new LinkedList(); --> creates an empty linked list object.
2.LinkedList ll = new LinkedList(Collection c); --> creates an equivalent linked list object for given collection.

LINKEDLIST CLASS SPECIFIC METHODS:
1.void addFirst(Object o);
2.void addLast(Object o);
4.Object getLast();
5.Object getFirst();
6.Object removeFirst();
7.Object removeLast();

DIFFERENCE BETWEEN ARRAYLIST AND LINKEDLIST:
--------------------------------------------------+-------------------------------------------------+
		ArrayList                         |                  LinkedList                     |
--------------------------------------------------+-------------------------------------------------+
1.Best choice if our frequent operation is        |     1.Best choice if our frequent operation is  |
  retrieval.                                      |       insertion or deletion.                    |
2.Worst choice if our frequent operation is       |     2.Worst choice if our frequent operation is |
  insertion or deletion in middle bcoz several    |       retrieval.                                |
  shift operations have to be performed.          |                    				    |
3.In ArrayList the elements will be stored in     |     3.Elements won't be stored in consecutive   |
  consecutive memory locations and hence 	  |	  memory locations and hence retrieval will |
  retrieval operation will be easy.               |       difficult.				    |
----------------------------------------------------------------------------------------------------+


------------------------------------------------------------------------------------------------------------------------------------------------------------
VECTOR:
-The underlying data structure is resizable or growable array.
-Insertion order is preserved.
-Duplicates are allowed.
-Heterogenous allowed.
-null inserton allowed.
-It implements Cloneable, Serializable and RandomAccess interface.
-Every method present in Vector is synchronized and hence thread safe.

CONSTRUCTORS OF VECTOR:
1.Vector v = new Vector();
  -Creates an empty vector object with default initial capacity 10. Once vector reaches it's max capacity then a new vector object will be created with new capacity.
   newCapacity = currentCapacity * 2

2.Vector v = new Vector(int initialCapacity);
  -Creates an empty vector object with given initial capacity.

3.Vector v = new Vector(int initialCapacity, int incrementalCapacity);
  -Creates an empty vector of initialCapacity and then increases its capacity by incrementalCapacity once the currentCapacity is crossed.

4.Vector v = new Vector(Collection c);
  -Creates an equivalent vector object for the given collection. This constructor meant for inter-conversion between Collection object.

VECTOR SPECIFIC METHODS:
-boolean add(Object o);
-void add(int index, Object o);
-void addElement(Object o);

To remove object
-boolean remove(Object o);  Collection
-Object remove(int index);  List
-removeElement(Object o);   v
-removeElementAt(int index);  v
-clear();  c
-removeAllElements();  v

To get object
Object get(int index) - L
Object elementAt(int index) - L
Object firstElement()  - v
Object lastElement()  - v

-------------------------------------------------------------------------------------------------------------------------------------------------------------
STACK:
-It is the child of Vector class.
-It is specifically designed class for LIFO.
-Only one constructor present.

Stack s = new Stack();

METHODS:
-Object push(Object o); --> to insert element into stack.
-Object pop();  -> to remove topmost element from the stack and return it.
-Object peek();  --> to return topmost element without removal
-boolean empty();  --> return true if stack is empty
-int search(Object o);  --> return offset if the element is available otherwise -1.
 offset start from topmost element and start from 1 and goes towards bottom.
-Insertion order is preserved.

-------------------------------------------------------------------------------------------------------------------------------------------------------------
THREE CURSORS OF JAVA:
-If we want to get object one by one from Collection then we should go for cursor.
-There are three types of cursor in java:
 1.Enumeration
 2.Iteration
 3.List iterator

ENUMERATION:
-We can use enumeration to get object one by one from legacy Collection Object. We can create enumeration object by using elements() method of Vector Class.
 public Enumeration elements();

Methods:
1.public boolean hasMoreElements();
2.public Object nextElement();

LIMITATIONS OF ENUMERATION:
-We can apply Enumeration object only for legacy classes & it is not universal cursor.
-By using Enumeration we can get only read access & cannot perform remove operation.
To overcome above limitations we should go for Iterator.

--------------------------------------------------------------------------------------------------------------------------------------------------------
ITERATOR:
-We can apply Iterator for any Collection object and hence it is universal cursor.
-By using Iterator we can perform read and remove operation.
-We can create Iterator object by using iterator() method of Collection Interface.

METHODS:
1.public boolean hasNext();
2.public Object next();
3.public void remove();

LIMITATIONS OF ITERATOR:
-By using Enumeration and Iterator we can always move in forward direction and not backward direction. These are single direction cursor but not bidirectional
 cursor.
-By using we can perform only read and remove operations but we cannot perform replacement and addition of new object.
To overcome above limitations we should go for ListIterator.
------------------------------------------------------------------------------------------------------------------------------------------------------------

LISTITERATOR:
-By using ListIterator we can move either to the forward direction or backward direction and hence it is bidirectional cursor.
-By using ListIterator we can perform replacement and addition of new object in addition to read and remove operation.
-We can create ListIterator by using listIterator() method of List interface.

public ListIterator listIterator();

MEHTODS:
ListIterator is the child interface of Iterator and hence all methods present in Iterator by default available to ListIterator.
1.public boolean hasNext();
2.public Object next();
3.public int nextIndex();
4.public boolean hasPrevious();
5.public Object previous();
6.public int previousIndex();
7.public void remove();
8.public void add(Object o);
9.public void set(Object o);

NOTE: The most powerful cursor is ListIterator but it's limitation is that it is applicable only for List objects.

COMPARISON TABLE OF THREE CURSORS:

     Property                        Enumeration                       Iterator                        ListIterator
1.Where we apply                      Legacy                       All Collection objects              List objects
2.Is legacy                            Yes                              No                                No 
3.Movement			     Forward                          Forward                          Bidirectional
4.Allowed operation                 Only read                        Read and Remove               read, remove, add and set
5.How we can get?              By using elements method           By using Iterator() method       By using listIterator() method
                               of Vector class                    of Collection interface          of List interface.

6.Methods                      hasMoreElements(),next()           hasNext(), next(), remove()      Above 9 methods written 

--------------------------------------------------------------------------------------------------------------------------------------------------------------
SET:
-It is the child interface of Collection interface.
-If we want to represent group of objects as a single entity where duplicates are not allowed and insertion order is not preserved.
-Set interface does not have any new methods and we have to use Collections interface methods.

HASHSET:
-The underlying data structure is Hash Table.
-Duplicates are not allowed.
-Insertion order is not preserved and it is based on hashcode of object.
-null insertion is possible only once.
-Heterogenous objects are allowed.
-Implements Serializable, Cloneable but not RandomAccess interface.
-HashedSet is the best choice if our frequent operation is search operation.

NOTE: 
1.In HashSet duplicates are not allowed but if we're trying to insert duplicate we won't get any compile-time or runtime error. Simply add() will return false.

CONSTRUCTORS:
1.HashSet hs = new HashSet();
  Creates an empty HashSet object with default capacity 16 and default fill ratio of 0.75.

2.HashSet hs = new HashSet(int initialCapacity);
  Creates an empty HashSet object with specified initial capacity and default fill ratio is 0.75.

3.HashSet hs = new HashSet(int initialCapacity, float fillRatio);
  Creates an empty HashSet object with specified initial capacity and specified fill ratio.

4.HashSet hs = new HashSet(Collection c);
  Creates an equivalent HashSet for the given collection. This constructor meant for inter-conversion between Collection object.

LOAD FACTOR/FILL RATIO:
-After filling how much ratio a new HashSet object will be created. This ratio is called load factor.
-filled ratio = 0.75 means after filling 75% capacity a new HashSet object will be created.
-------------------------------------------------------------------------------------------------------------------------------------------------------------
LINKED HASH SET:


                   HashSet                                             LinkedHashSet
   1.Underlying data structure is hash table.         1.Underlying data structure is combination of
							linked list and hash table.
   2.Insertion order is not preserved                 2.Insertion order is preserved bcoz of linked
							list.


-------------------------------------------------------------------------------------------------------------------------------------------------------------
SORTED SET:
-SortedSet is the child interface of Set.
-If we want to represent a group of individual objects according to some sorting order without duplicates then we should go for SortedSet.

SortedSet interface defines the following specific methods:
1.Object first(); - return the first element of sorted set.
2.Object last(); - returns the last element of sorted set.
3.SortedSet headSet(Object obj); - returns sorted set whose elements are less than obj.
4.SortedSet tailSet(Object obj); - returns sorted set whose object elements are greater than or equal to obj.
5.SortedSet subSet(Object obj1, Object obj2); - returns sorted set whose element are greater than or equal to obj1 and less than obj2.
6.Comparator comparator(); - returns Comparator object that describes the sorting techniques. If we're using default natural sorting order then we'll get null.

NOTE: The default natural sorting order for number is ascending order and for String objects is alphabetical order.

-------------------------------------------------------------------------------------------------------------------------------------------------------------

TREESET:
-Underlying data structure is balanced tree.
-Duplicates are not allowed.
-Insertion order is not preserved.
-Heterogenous objects are not allowed otherwise we'll get runtime exception saying "ClassCastException".
-null insertion are possible only once.
-TreeSet implements Serializable and Cloneable but not RandomAccess interface.
-All objects will be inserted based on some sorting order. It may be default natural or customized.

CONSTRUCTORS:
1.TreeSet ts = new TreeSet();
  Creates an empty TreeSet object where the elements will be inserted according to default natural sorting order.

2.TreeSet ts = new TreeSet(Comparator c);
  Creates an empty TreeSet object where the elements will be inserted according to customized sorting order specified by Comparator object.

3.TreeSet ts = new TreeSet(Collection c);

4.TreeSet ts = new TreeSet(SortedSet s);

NULL ACCEPTANCE:
-For non-empty TreeSet if we're trying to insert null then we'll get NullPointerException.
-For empty TreeSet as a first element null is allowed but after inserting that if we're trying to insert other, then we'll get runtime exception
 saying NullPointerException.

NOTE: Until 1.6v null was allowed as the first element to the empty TreeSet but from 1.7v onwards null is not allowed even as the first element.

VERY IMP POINT:
-If we're depending on default natural sorting order compulsory the object should be homogenous and Comaparable otherwise we'll get runtime exception saying
 ClassCastException.
-An object is said to be comparable if and only if corresponding class implements Comparable interface.
 String class and all the Wrapper classes implements Comparable interface. But the class that doesn't implements Comparable interface in that scenario we'll
 ClassCastException.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

COMPARABLE INTERFACE:
-It is present in java.lang package.
-It contains only one method public int compareTo(Object obj);
 obj1.compareTo(obj2);
-Returns negative integer if obj1 has to come before obj2.
-Returns positive integer if obj1 has to come after obj2.
-Returns zero if obj1 and obj2 are equal.

NOTE: If default natural sorting order not available or if we're not satisfied with default natural sorting order then we can go for customized sorting by using
      Comparator.
      Comparable meant for default natural sorting order whereas Comparator meant for customized sorting order.

COMPARATOR INTERFACE:
-It is present in java.util package.
-It has two methods
 1.public int compare(Object obj1, Object obj2);
  Return negative if obj1 has to come before obj2.
  Return positive if obj1 has to come after obj2.
  Returns zero if obj1 and obj2 are equal.
 2.public boolean equals(Object obj);

-Whenever we're implementing Comparator interface compulsory we should provide implementation of compare() method and we're not required to provide implementation of
 equals method as it already available as it already available to our class through Object class bcoz of inheritance.

VARIOUS POSSIBLE IMPLEMENTATIONS OF COMPARE METHOD OF COMPARATOR INTERFACE:

public int compare(Object o1, Object o2) {
	Integer i1 = (Integer) o1;
	Integer i2 = (Integer) o2;
	return i1.compareTo(i2);    //default sorting order (ascending order)
}

public int compare(Object o1, Object o2) {
	Integer i1 = (Integer) o1;
	Integer i2 = (Integer) o2;
	return -i1.compareTo(i2);    //descending order
}

public int compare(Object o1, Object o2) {
	Integer i1 = (Integer) o1;
	Integer i2 = (Integer) o2;
	return i2.compareTo(i1);    //descending order
}

public int compare(Object o1, Object o2) {
	Integer i1 = (Integer) o1;
	Integer i2 = (Integer) o2;
	return -i2.compareTo(i1);    //descending order
}

public int compare(Object o1, Object o2) {
	Integer i1 = (Integer) o1;
	Integer i2 = (Integer) o2;
	return 1;    //elements are added as per insertion order
}

public int compare(Object o1, Object o2) {
	Integer i1 = (Integer) o1;
	Integer i2 = (Integer) o2;
	return -1;    //elements are added as per reverse of insertion order
}

public int compare(Object o1, Object o2) {
	Integer i1 = (Integer) o1;
	Integer i2 = (Integer) o2;
	return 0;    //only first element will be inserted and treats all other elements as duplicates.
}

DIFFERENCE BETWEEN COMPARABLE AND COMPARATOR: 
--------------------------------------------------------------------------------------------------+
           COMPARABLE                         |       		COMPARATOR                        |
--------------------------------------------------------------------------------------------------+
1.Meant for default natural sorting order     |    1.Meant for customized soting order.           |
2.Present in java.lang package                |    2.Present in java.util package                 |
3.Defines only one method :                   |    3.Defines two methods:                         |
  compareTo(Object obj)                       |      compare(Object o1, Object o2), equals()      |
                              		      |							  |
4.String and all Wrapper classes implements   |    4.The only implementation class of Comparator  |
  Comparable interface.                       |      is Collector.                                |
--------------------------------------------------------------------------------------------------+

Q.Write a program to insert String and StringBuffer object into TreeSet where sorting order is increasing length order.
  If two objects having same length then consider their alphabetical order.

Q.Create a class Employee (name, roll_no). Insert into TreeSet and sort them according to roll_no and name using customized sorting order.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------+
	Properties		   |		HashSet		   |		LinkedHashSet		  |		TreeSet             |
--------------------------------------------------------------------------------------------------------------------------------------------+
  1.Underlying data structure      |          Hash Table	   |	  Linked list and Hash Table      |          Balanced Tree          |
  2.Duplicate object               |         Not Allowed           |            Not Allowed               |            Not Allowed          |
  3.Insertion order                |         Not preserved         |             Preserved                |           Not Preserved         |
  4.Sorting Order                  |             NA                |                NA                    |            Applicable           |
  5.Heterogenous objects           |           Allowed             |              Allowed                 |           Not Allowed           |
  6.null acceptance                |       Allowed only once       |         Allowed only once            |       Not Allowed after 1.7v    |
--------------------------------------------------------------------------------------------------------------------------------------------+

----------------------------------------------------------------------------------------------------------------------------------------------------------------
MAP:
-It is not child interface of Collection interface.
-If we want to represent a group of objects as key-value pair then we should go for Map.
-Both keys and values are object only.
-Duplicate keys are not allowed but values can be duplicated.
-Each key-value pair is called entry hence map is considered as a collection of entry objects.

MAP INTERFACE METHODS:
1.Object put(Object key, Object value);
  To add one key-value pair to the map.
  If the key is already present then old value will be replaced with new value and return old value.

2.void putAll(Map m);
  To add a group of key-value pairs.

3.Object get(Object key);
  Returns a value associated with specified key.

4.Object remove(Object key);
  Removes the entry associated with specified key.

5.boolean containsKey(Object key);

6.boolean containsValue(Object value);

7.boolean isEmpty();

8.int size();

9.void clear();

10.Set keySet();
   Returns all keys.

11.Collection values();
   Returns all values of Map.

12.Set entrySet();
   Returns the Set of entries.
---------------------------------------------------------------------

ENTRY INTERFACE:
-A map is group of key-value pairs and each key-value pair is called entry hence Map is considered as a collection of Entry objects.
-Without existing Map object there is no chance of existence of Entry object hence Entry interface is defined inside Map interface.

interface Map {
   ......
   interface Entry {
   	Object getKey();
   	Object getValue();
	Object setValue(Object new);
   }
}


HASHMAP:
-The underlying data structure is hash table.
-Insertion order is not preserved and it is based on hashcode of keys.
-Dulicate keys are not allowed but values can be duplicated.
-Heterogenous objects are allowed for both key and values.
-null is allowed for key only once.
-null is allowed for values any number of times.
-HashMap implements Serializable and Cloneable interface but not RandomAccess.
-Best choice if our frequent operation is searching.

CONSTRUCTORS OF HASHMAP:
1.HashMap hm = new HashMap();
  It creates an empty HashMap object with default initial capacity 16 and default fill ratio of 0.75.

2.HashMap hm = new HashMap(int initialCapacity);
  It creates an empty HashMap object with specified initial capacity and default fill ratio of 0.75.

3.HashMap hm = new HashMap(int initialCapacity, float fillRatio);

4.HashMap hm = new HashMap(Map m);
-----------------------------------------------------------------------------------------------------------------

DIFFERENCE BETWEEN HASHMAP AND HASHTABLE:

		   HASHMAP								HASHTABLE
1.Every method present in HashMap is non-synchronized.		1.Every method present in HashTable is syncronized.
2.At a time multiple threads are allowed to operate             2.At a time only one thread is allowed to operate on
  on HashMap object hence not thread safe.        		  HashTable hence thread safe.
3.Relatively performance is high bcoz thread are not		3.Relatively performance is low bcoz thread is reqd to
  required to wait.						  wait.
4.null is allowed for both key(once) and value(multiple).       4.null not allowed.
5.Introduced in 1.2v and it is not legacy.                      5.Introduced in 1.0 version and is legacy.
  
NOTE: By default HashMap is non-synchronized and to make it synchronized we can use below method:
      Map m = Collections.synchronizedMap(Map hm);

Q.What is the difference between HashTable and synchronized HashMap? (Fail fast Fail safe concept).

------------------------------------------------------------------------------------------------------------------------------------------------
LINKED HASH MAP:
-It is the child class of HashMap.
-It is exactly same as HashMap including methods and constructor except the following differences.

		HASHMAP							LINKEDHASHMAP
1.Underlying data structure is hash table.			1.Underlying data structure is linked list
								  and hash table.
2.Insertion order is not preserved				2.Insertion order is preserved
3.Introduced in 1.2v						3.Introduced in 1.4v

DIFFERENCE BETWEEN == AND .equals() method:
-In genral == operator meant for reference comparison or adddress comparison whereas .equals() method meant for content comparison.

IDENTITY HASP MAP:
-It is exactly same as HashMap including methods and constructor except the following differences:
-In the case of normal HashMap JVM will use .equals() methods- to identify duplicate keys which is meant for content comparison but in the case of IdentityHashMap
 JVM will use == operator to identify duplicate keys which is meant for reference comparison.

In the given example i1 and i2 are duplicate keys because i1.equals(i2) returns true in normal HashMap.
But if we replace HashMap with IdentityHashMap then i1 and i2 are not duplicate keys bcoz i1==i2 returns false and in this output is {10=person, 10=person}.

e.g.
		HashMap hm = new HashMap();
		Integer i1 = new Integer(10);
		Integer i2 = new Integer(10);
		
		hm.put(i1, "person");
		hm.put(i2, "person");
		
		System.out.println(hm);  //{10=person}


		
		IdentityHashMap ihm = new IdentityHashMap();
		Integer i1 = new Integer(10);
		Integer i2 = new Integer(10);
		
		ihm.put(i1, "person");
		ihm.put(i2, "person");
		
		System.out.println(ihm); //{10=person, 10=person}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
WEAKHASHMAP:
-It is exactly same as HashMap except the following differences:
-In Case of HashMap even though object do not have any reference it is not eligible for garbage collection
 If it is associated with HashMap i.e., HashMap dominates garbage collector.
-But in the the case of WeakHashMap if the object does not contain any reference it is eligible for garbage collection even though object 
 is associated with WeakHashMap i.e., garbage collector dominates WeakHashMap.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

SORTED MAP:
-It is child interface of Map interface.
-If we want to represent a group of objects as a group of key-value pair according to some sorting order of keys then we should go for SortedMap.
-Sorting is based on keys but not values.

METHODS:
1.Object firstKey();
2.Object lastKey();
3.SortedMap headMap(Object key);
4.SortedMap tailMap(Object key);
5.SortedMap subMap(Object key1, Object key2);
6.Comparator comparator();
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TREEMAP:
-Underlying data structure is red-black tree.
-Insertion order is not preserved and it is based on some sorting of keys.
-Duplicate keys are not allowed but values can be duplicated.
-If we're depending on default natural sorting order then keys should be homogenous and implements Comaparable interface otherwise we'll get runtime exception saying ClassCastException.
-If we're defining our own sorting by Comparator then key need not to be homogenous and Comaparable.
-Whether we're depending on default natural sorting order or customized sorting order there are no restrictions for values we can take heterogenous non-comaparable object also.

NULL ACCEPTANCE:
-For non-empty TreeMap if we're trying to insert and Entry with null key then we'll get runtime exception saying NullPointerException.
-For empty TreeMap as the first Entry with null key is allowed but after inserting that Entry if we're trying to insert any other Entry then we'll get any other Entry saying NullPointerException.

NOTE: The above null acceptance rule is applicable until 1.6v only. From 1.7v onwards null is not allowed for keys but for values we can use null any numer of time (no restrictions).

CONSTRUCTOR:
1.TreeMap tm = new TreeMap();
  Creates an empty TreeMap with default natural sorting order.

2.TreeMap tm = new Treemap(Comparator c);

3.TreeMap tm = new TreeMap(SortedMap sm);

4.Treemap tm = new TreeMap(Map m);
_______________________________________________________________________________________________________________________________________________________________________________________________________________

HASHTABLE:
-Underlying data structure is JavaClass HashTable.
-Insertion is not preserved and it is based on hashcode of keys.
-Duplicate keys are not allowed nad values can be and values can be duplicated.
-Heterogenous objects are allowed for both keys and values.
-null is not allowed for both keys and values otherwise we'll get NullPointerException.
-It implements Serializable, Cloneable but not RandomAccess.
-Every method present in HashTable is synchronized hence HashTable object is thread safe.
-Best choice if frequent operation is searching.

CONSTRUCTORS:
1.HashTable ht = new HashTable();
  Creates empty HashTable object with default initial capacity of 11 and default fill ratio of 0.75.

2.HashTable ht = new HashTable(int initialCapacity);
  Creates an empty HashTable object with specified initial capacity.

3.HashTable ht = new HashTable(int initialCapacity, float fillRatio);
  Creates an empty HashTable object with specified initial capacity and specified fill ratio.

4.HashTable ht = new HashTable(Map m);
_________________________________________________________________________________________________________________________________________________________________________________________________

QUEUE:
-It is the child interface of Collection interface.
-If we want to represent a group of individual objects prior to processing then we shoul go for queue.
 For e.g. Before sending SMS messages all mobile numbers are stored in some data structure in which order we added mobile numbers in the same order only message 
          should be delivered. For this FIFO requirement, Queue is the best choice.
-Usually Queue follows FIFO order. But based on our requirement we can implement our own priority order(PriorityQueue).
-From 1.5v onwards LinkedList class also implements Queue interface.
-LinkedList based implementation of Queue followed by FIFO order.

METHODS:
1.boolean offer(Object o);
  To add an object into the queue.

2.Object peek();
  To return head element of the queue, if the queue is empty then returns null.

3.Object element();
  To return head element of the queue, if the queue is empty then this method raises runtime-exception NoSuchElementFoundException.

4.Object poll();
  To remove and return head element of the queue. If the queue is empty then returns null.

5.Object remove();
  To remove and return head element of the queue. If the queue is empty then this method raises runtime-exception NoSuchElementFoundException.
____________________________________________________________________________________________________________________________________________________________________________________________________

PRIORITY QUEUE:
-IF we want to represent a group of individual objects prior to processing according to some priority order then we should go for PriorityQueue.
-The Priority can be either default natural priorty or customized priority defined by Comparator.
-Insertion order is not preserved and it i based on some priority.
-Duplicate objects are not allowed.
-If we're depending on default natural sorting order, object should be homogenous and Comparable. Otherwise we'll get runtime exception saying ClassCastException.
-If we're defining our own sorting by Comparator then object need not to be homogenous and Comparable.
-null insertion is not allowed even as a first element also.

CONSTRUCTORS:
1.PriorityQueue pq = new PriorityQueue();
  Creates an empty priority queue with default initial capacity 11 and all objects will be inserted according to default natural sorting order.

2.PriorityQueue pq = new PriorityQueue(int initialCapacity);
  Creates an empty priority queue with specified initial capacity.

3.PriorityQueue pq = new PriorityQueue(int initialCapacity, Comparator c);

4.PriorityQueue pq = new PriorityQueue(Comparator c);

5.PriorityQueue pq = new PriorityQueue(SortedSet s);

6.PriorityQueue pq = new PriorityQueue(Collection c);

NOTE: Some platform won't support for thread priorities and priority queues.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
EXCEPTION HANDLING:
Introduction:
-An unwanted or unexpected event that disturb the normal flow of program is called exception.
-If we want graceful termination then we should go for exception handling so that if something goes wrong we should not miss anything or loose something.

Purpose of Exception Handling:
-Graceful termination of program if something goes wrong we should not miss anything.

Definition:
-Exception Handling is the process of defining alternative ways to continue rest of the program normally.

Runtime Stack mechanism:
-Every java program contains atleast one thread. For every thread JVM will create one runtime stack.
-Every method call is performed by thread. One entry will be saved in stack for every method call. This stack entry is called stack frame or activation record.
-Once method call is completed, corresponding entry from stack will be removed.
-After completing all the method calls once thread got terminated, JVM will destroy this stack.

e.g.
public class Test {

	public static void main(String[] args) {
		doStuff();
	}
	
	public static void doStuff() {
		doMoreStuff();
	}
	
	public static void doMoreStuff() {
		System.out.println("Hello");
	}
}

	|                     |
	|		      |
	|                     |
	|---------------------|
	|    doMoreStuff()    |
        |---------------------|
	|      doStuff()      |
	|---------------------|
	|       main()        |
	+---------------------+
         Fig. Runtime Stack

-After completing the call of doMoreStuff() it is removed from the stack. Now we return to doStuff() and after completing doStuff() it is removed from the stack then after completing main method
 before terminating main thread all the stack will be destroyed by JVM.
-Each entry in the stack is called activation record or stack frame.

e.g.
public class Test {

	public static void main(String[] args) {
		doStuff();
	}
	
	public static void doStuff() {
		doMoreStuff();
	}
	
	public static void doMoreStuff() {
		System.out.println(10/0);
	}
}

	|                     |
	|		      |
	|                     |
	|---------------------|
	|    doMoreStuff()    |
        |---------------------|
	|      doStuff()      |
	|---------------------|
	|       main()        |
	+---------------------+
         Fig. Runtime Stack

-Inside a method if any exception rise then the method in which it is raised is responsible to create exception object with the help of JVM.

 Exception object is created like this with the help of stack trace.
 O/P:
 Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.ExceptionHandling.Test.doMoreStuff(Test.java:15)
	at com.ExceptionHandling.Test.doStuff(Test.java:10)
	at com.ExceptionHandling.Test.main(Test.java:6)
 With this information exception will be raised and the method in which exception rised will handover that exception object to JVM.

-If we haven't handled exception in our code then JVM terminates all the methods and uses default exception handler to print all the exceptions and stack trace at console.
 
 In the above example it checks who is the caller of the method and whether that method handles that exception or not. If not then terminate that method.
 
 In the above example doMoreStuff() method is responsible to raise the exception object, JVM will ask doMoreStuff() who is the caller of that method and whether that 
 method handles that exception, If not then JVM will ask doStuff() who is the caller and whether that method has handled that exception, here in this case main() is the caller
 of doStuff() method, then JVM will check that whether main() has handled that exception, then main method replies that "I have not handled exception" and the caller of main
 is JVM itself then JVM is itself responsible to handle that exception. JVM has a assistant called default dispatcher handler which is responsible to print all the
 information of exception object at console.

 e.g.
 public class Test2 {

	public static void main(String[] args) {
		doStuff();
	}
	
	public static void doStuff() {   //abnormal termination
		doMoreStuff();
		System.out.println(10/0);
	}
	
	public static void doMoreStuff() {   //completed normally
		System.out.println("Hello");
	}
	
 }

 O/P:  
 Hello
 Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.ExceptionHandling.Test2.doStuff(Test2.java:11)
	at com.ExceptionHandling.Test2.main(Test2.java:6)

 e.g.
 public class Test3 {
	public static void main(String[] args) {
		doStuff();
		System.out.println(10/0);
	}
	
	public static void doStuff() {
		doMoreStuff();
		System.out.println("Hi");
	}
	
	public static void doMoreStuff() {
		System.out.println("Hello");
	}
 }

 O/P:
 Hello
 Hi
 Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.ExceptionHandling.Test3.main(Test3.java:6)



-If the method completes normally, JVM will remove that corresponding method entry from runtime stack.
-So inside which method exception raised ?  -> doStuff() so this method is responsible to create an exception object and handover it to JVM. But, there is no handling code so JVM will terminate
 doStuff() method abnormally and remove the corresponding method entry from runtime stack. Then JVM checks who is the caller of doStuff() method then JVM will come to know main() is the caller
 and now JVM will check whether main() has handled that exception. If not, JVM will terminate main() abnormally and remove the entry from the runtime stack. Now JVM realises that he is itself
 the caller of main() so JVM will be responsible to handle that exception using Default Dispatcher handler and print the exception object on the console.

-In this case main method is responsible to raise the exception object and handover to JVM. But, main() has not handled the exception and then JVM will check who is the caller of main() and it
 realises that he himself is the caller and then asks default dispatcher handler to create the exception object and print on the console.


								    Throwable (occurs root for all exception and error classes)
                                                ________________________|________________________________________________
                                               |                                                                         |
                                           Exception                                                                   Error
          _____________________________________|________________________________________                     ____________|___________
         |                               |                            |                 |                   |                        |  
    RuntimeException                IOException                 SQLException    InterruptedException     VMError                 LinkingError
     |-ArithmeticException           |-FileNotFoundException					    ________|_________               |
     |-NullPointerException          |-EOFException						   |                  |          VerifyError
     |-ClassCastException								   StackOverFlowError  OutOfMemoryError
     |-IndexOutOfBoundException
     |  |-ArrayIndexOutOfBoundException
     |  |-StringIndexOutOfBoundException
     |
     |-IllegalArgumentsException
        |-NumberFormatException


Difference between Exception and Error:
-Exceptions are caused by our programmers.
-Exceptions are recoverable and programmers are responsible to recover.

-Errors are not caused by programmer and Errors are non-recoverable if something crashes.

e.g.
public class Test4 {

	public static void main(String[] args) {
		
		PrintWriter pw = new PrintWriter("abc.text");  //Compile-time error, Unhandled Exception FileNotFoundException
		pw.println("hello");
	}
}

public class Test4 {

	public static void main(String[] args) throws FileNotFoundException{
		
		PrintWriter pw = new PrintWriter("abc.text");  //OK
		pw.println("hello");
	}

}

e.g.
public class Test4 {

	public static void main(String[] args) {
		
		System.out.println("I want to sleep");
		Thread.sleep(1000);  //Compile-time error, Unhandled Exception InterruptedException
	}

}

NOTE: The exceptions which are checked by compiler for smooth execution of program at runtime whether programmer is handling or not such type of 
      exceptions are called checked exceptions.
      The exceptions which are not checked by compiler whether programmers handles it or not are called Unchecked exceptions.

Difference Between Partially-Checked and Fully-Checked Exceptions:
-The only possible partially checked exceptions in java are Exception class and Throwable class, except this all are fully-checked exceptions.
 IOException -> fully-checked
 RuntimeException -> fully-unchecked
 Error -> fully-unchecked
-------------------------------------------------------------------------------------------------------------------------------------------------------------

CUSTOMIZED EXCEPTION HANDLING BY TRY-CATCH:
e.g.
public class TryCatchExample {

	public static void main(String[] args) {
		System.out.println("Statement - 1");
		
		try {
			System.out.println(10/0);
		} catch(ArithmeticException ae) {
			System.out.println(10/2);
		}
		
		System.out.println("Statement - 3");
	}

}

Syntax of try-catch:
try {
	//risky code
}
catch(Exception e) {
	//handling code
}

NOTE: Risky code should be used in try block and handling code in catch block.

e.g.
try {
	statement 1;
	statement 2;
	statement 3;
}
catch(XXX e) {
	statement 4;
}
statement 5;

CASE 1: If there is not an exception
-All the blocks will be executed except catch (1-2-3-5)

CASE 2: If an exception raised at Statement 2 and the corresponding catch block matched.
-If some statement raised an exception at try block them immediately it will go to catch block then again try block will not execute.
-The statements executed will be 1-2-4-5.

CASE 3: If an exception raised at statement 2 and corresponding catch block is not matched.
-Abormal termination since no catched block is matched.

CASE 4:If an exception raised at statement 4
-Out of statement 1, 2 or 3 has caused exception then only it has entered into the catch block and inside catch block at statement 4 exception
 raised then program will abnormally terminate.

NOTE: 
1.Length of try block code should be as less as possible(good coding practice) bcoz in try block if exception raise anywhere then rest of the
  code will not execute eventhough we handle the exception.
2.After control came to catch block it will not go to try block again.
3.Inside try block we have to take risky code not normal code.
4.Exception can be raised in catch block and finally block as well, after-all we write java code there anywhere is the possibility to raise exception.
5.catch block is always associated with try block.
6.If any statement which raise an exception outside the try block then catch block is not responsible. It is always abnormal termination.
7.If you want to handle exception inside catch block try-catch over there. We can use try-catch inside catch block.

METHODS TO PRINT EXCEPTION INFORMATION:
-Throwable class contains 3 methods to print all the exception information to console.
1.printStackTrace();  
2.toString();  //inside sop  --> java.lang.ArithmeticException: / by zero
3.getMessage();  //inside sop  --> gives description of the error.

NOTE: 
1.Default exception handler always uses printStackTrace() method whenever we're not handling exception.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TRY WITH MULTIPLE CATCHES:
-For every exception separate catch block must be required.
-If we use single catch block Exception object then it is worst programming practice.
-For all exceptions one catch block not recommended to use(worst programming practice).
 e.g.
 		try {
			AE
			FNF
			NPE
		} catch(ArithmeticException e) {
			
		} catch(FileNotFoundException e) {
			
		} catch(NullPointerException e) {
			
		} catch(Exception e) {
			
		}
-If any exception other than given exception raised then catch(Exception e) will be excuted.
-If there is a multiple catch blocks then JVM will execute catch blocks from top to bottom.
-Catch block with parent exception can handle child exception also.
-Order of catch block is very important. In multiple catch blocks compulsory we have to go from child exception to parent exception from top to bottom
 not parent to child.
 e.g.
 		try {
			System.out.println(10/0);
		} 
		catch(Exception e) {
			
		} 
		catch(ArithmeticException e) {  //compile-time error, Unreachable catch block for ArithmeticException. It is already handled by the catch block for Exception
			
		}

 e.g.
 		try {
			System.out.println(10/0);
		} 
		catch(ArithmeticException e) {
			
		} 
		catch(Exception e) {  //works fine
			
		}

-We cannot declare same exception again and again.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
FINALLY BLOCK:
-Never recommended to use cleanup code inside try block.If any exception raised then cleanup code will not execute. If exception raised while reading the data then the flow will go 
 to catch block so the DB conection will not close and the resource will be wasted. So it is never recommended to use cleanup code inside try block.There is no guarantee to execute
 every statement in try block.
 try {
	//open DB connnection
	//read data
	//clean up code         //invalid
 }
 catch(Exception e) {

 }

-Below code is also not recommended bcoz if exception will not rise then it will not go to catch block and hence resources will be wasted.

 try {
	//open DB connnection
	//read data
	
 }
 catch(Exception e) {
	//clean up code         //invalid
 }

FINALLY:
-Finally block should be executed always exception raised, exception not raised, abnormal termination, normal termination always it should be executed.
-Always recommended to use clean up code in finally block.
 try {
	//risky code
 }
 catch(XXX e) {
 	//handling code
 }
 finally {
	//clean up code
 }

 e.g.		try {
			System.out.println("try");
			System.out.println(10/0);
		}
		catch(Exception e) {
			System.out.println("caught exception");
		}
		finally {
			System.out.println("finally");
		}

  O/P: try
       caught exception
       finally

 e.g.		try {
			System.out.println("try");
			System.out.println(10/0);
		}
		catch(NullPointerException e) {    //exception not matched, hence abnormal termination but finally will still be executed.
			System.out.println("caught exception");
		}
		finally {
			System.out.println("finally");
		}
  O/P:
  try
  finally
  Exception in thread "main" java.lang.ArithmeticException: / by zero
	  at com.ExceptionHandling.TryCatchFinallyExample.main(TryCatchFinallyExample.java:9)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

FINALLY BLOCK V/S RETURN STATEMENT:
-Whenever return statement will be there JVM will ask them to wait until I execute finally block.
e.g.
public class FinallyAndReturn {

	public static void main(String[] args) {
		
		try {
			System.out.println("try");
			return;
		}
		catch(Exception e) {
			System.out.println("catch");
		}
		finally {
			System.out.println("finally");
		}
	}
}

O/P:
try
finally


Q.If all the blocks return something then which block will be executed?
e.g.
public class Example1 {

	public static void main(String[] args) {
		System.out.println(m1());  //999
	}
	
	public static int m1() {
		try {
			return 777;
		}
		catch(Exception e) {
			return 888;
		}
		finally {
			return 999;
		}
	}

}

O/P:
999

--------------------------------------------------------------------------------------------------------------------------------------------------------------
FINALLY BLOCK V/S SYSTEM.EXIT(0):
-If JVM gets shutdown then there is no chance to execute finally block. In code we can achieve this by System.exit(0).(Only one condition when finally block will not
 execute because JVM is responsible to execute finally block, and if JVM gets shutdown then there is nobody who can execute finally block).

e.g.
public class Example2 {

	public static void main(String[] args) {
		try {
			System.out.println("try");
			System.exit(0);
		}
		catch(Exception e) {
			System.out.println("catch");
		}
		finally {
			System.out.println("finally");
		}
	}
}

O/P:
try

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SYSTEM.EXIT(STATUS CODE):
-Status Code = 0 --> normal termination
-Status Code != 0 --> abnormal termination
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

CONTROL FLOW IN TRY-CATCH-FINALLY:

try {
	stmt - 1;
	stmt - 2;
	stmt - 3;
}
catch(Exception e) {
	stmt - 4;
}
finally {
	stmt - 5;
}
stmt - 6; (outside finally)

CASE 1: If there is no exception:
	Statements executed: 1-2-3-5-6

CASE 2: If an exception raised at statment 2 and corresponding catch block is matched.
	Statements executed: 1-4-5-6

CASE 3: If an exception raised at statement 2 and corresponding catch block not matched.
	Statements executed: 1-5 and then abnormal termination

CASE 4: If an exception raised at statement 4
        That means exception has been raised either at stmt-1 or stmt-2 or stmt-3
	Statements executed: 5
        Statements executed: 1-5
	Statements executed: 1-2-5

CASE 5: If exception raised at statement 5:
        Statements executed: 1-2-3

NOTE: If any statement raising the exception is written outside the try block then this will cause abnormal termination.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

NESTED TRY-CATCH-FINALLY:
Q.Is it possible to take try-catch inside another try-catch?
-> Yes we can take try-catch block inside another try block. We can take try-catch inside catch block as well and we can take try-catch inside finally block as well.

-Normal risky code we have to take in outer try-catch block.
-Too much risky code in inner try-catch block. So that rest of the code will execute normally.
e.g.
public class NestedTryCatch {

	public static void main(String[] args) {
		try {
			System.out.println("outer-try");
				try {
					System.out.println("inner-try");
					System.out.println(10/0);
				}
				catch(Exception e) {
					System.out.println("inner-catch");
				}
			System.out.println("After inner try-catch");
		}
		catch(Exception e) {
			System.out.println("outer-catch");
		}
		finally {
			System.out.println("finally block");
		}
	}

}

O/P:
outer-try
inner-try
inner-catch
After inner try-catch
finally block

-If inner-catch unable to handle then immediately outer catch block will be executed.
e.g.
public class NestedTryCatch {

	public static void main(String[] args) {
		try {
			System.out.println("outer-try");
				try {
					System.out.println("inner-try");
					System.out.println(10/0);
				}
				catch(NullPointerException e) {
					System.out.println("inner-catch");
				}
			System.out.println("After inner try-catch");
		}
		catch(Exception e) {
			System.out.println("outer-catch");
		}
		finally {
			System.out.println("finally block");
		}
	}

}

O/P:
outer-try
inner-try
outer-catch
finally block

e.g.
public class NestedTryCatch {

	public static void main(String[] args) {
		try {
			System.out.println("outer-try");
				try {
					System.out.println("inner-try");
					System.out.println(10/0);
				}
				catch(ArithmeticException e) {
					System.out.println(10/0);
				}
			System.out.println("After inner try-catch");
		}
		catch(Exception e) {
			System.out.println("outer-catch");
		}
		finally {
			System.out.println("finally block");
		}
	}

}

O/P:
outer-try
inner-try
outer-catch
finally block

-If outer catch doesn't match then abnormal termination.
-Very sensitive code is to be written inside inner try-block.

-------------------------------------------------------------------------------------------------

try {
	stmt - 1;
	stmt - 2;
	stmt - 3;
	try {
		stmt - 4;
		stmt - 5;
		stmt - 6;
	}
	catch(XXX e) {
	{
		stmt - 7;
	}
	finally {
		stmt - 8;
	}
	
	stmt - 9;
}
catch(YYY e) {
	stmt - 10;
}
finally {
	stmt - 11;
}
stmt - 12;

CASE 1: If there is no exception
	Statement executed: 1-2-3-4-5-6-8-9-11-12

CASE 2: If exception raised at statement 2 and corresponding catch block matched.
	Statements exectued: 1-10-11-12

NOTE: Once we entered into try block compulsory finally block will be executed. If we didn't entered into try block then finally block will not execute.
      Here if we're not entering inner-try then there is no need to go inner finally. That's why here in CASE 2 inner finally will not be executed.

CASE 3: If an exception raised at stmt - 2 and corresponding catch block not matched.
	Statements executed: 1-11 and then abnormal termination.

CASE 4: If an exception raised at stmt - 5 and corresponding catch block matched.
	Statements executed: 1-2-3-4-7-8-9-11-12

CASE 5: If an exception raised at stmt - 5 and inner catch block not matched but outer catch matched.
	Statements executed: 1-2-3-4-8-10-11-12

CASE 6: If an exception raised at stmt- 5 and both inner and outer catch block not matched.
	Statements executed: 1-2-3-4-8-11 and then abnormal termination.

CASE 7: If an exception raised at stmt - 7 and corresponding catch block matched.
	Three possibilities:
	Statements executed: 1-2-3-8-10-11-12
       	Statements executed: 1-2-3-4-8-10-11-12
	Statements executed: 1-2-3-4-5-8-10-11-12

CASE 8: If an exception raised at statement 7 and corr. catch block not matched.
	Three possibilities:
	Statements executed: 1-2-3-8-11 and then abnormal termination.
	Statements executed: 1-2-3-4-8-11 and then abnormal termination.
	Statements executed: 1-2-3-4-5-8-11 and then abnormal termination.

CASE 9: If an exception raised at stmt - 8 and corresponding catch block matched.
	Statements executed: 

CASE 10: If an exception raised at and corresponding catch block not matched.
         
 
CASE 11: If an exception raised at stmt - 9 and corr. catch block matched.
         

CASE 12: If an exception rasied at stmt - 9 and corr. catch block not matched.


CASE 13: If an exception raised at stmt - 10.


CASE 14: If an exception raised at stmt - 11.


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
VARIOUS POSSIBLE FLOWS OF TRY-CATCH-FINALLY:
-We can define try/catch/finally in any of the try/catch/finally.
-For try/catch/finally block curly braces are mandatory
e.g.

1.
try {

}
catch(X e) {

}
-Valid

2. 
try {

}
catch(X e) {

}
catch(Y e) {

}
-Valid

3.
try {

}
catch(X e) {

}
catch(X e) {

}
-Unreachable catch compile-time error.

4.
try {

}
catch(X e) {

}
finally {

}
-Valid

5.
try {

}
catch(X e) {

}
try {

}
catch(X e) {

}
-Valid

6.
try {

}
finally {

}
-Valid

7.
try {

}
-invalid (compilation error - try without catch or finally)

8.
finally {

}
-Invalid (finally ko try chahiye hi chahiye)

9.
catch(X e) {

}
-Invalid (compilation error - catch without try)

10.
try {

}
finally {

}
-Valid uptil this 
catch(X e) {

}
-Invalid (compilation error - catch wihtout try)

11.
try {

}
try {

}
catch(X e) {

}
finally {

}

-Invalid (compilation error, first try is without catch/finally)

12.
try {

}
catch(X e) {

}
catch(Y e) {

}
finally {

}
-Valid


13.
try {

}
sop("abc");
catch(X e) {

}
-Invalid (compilation error, no statement should be in b/w try and catch)

14.
try {

}
catch(X e) {

}
sop("hello");
finally {

}
-Invalid

15.
try {
	try {
 
        }
	catch(X e) {

	}
}
catch(Y e) {

}
-Valid

16.
try {
	try {
 
        }
	catch(X e) {

	}
}
catch(X e) {

}
-Valid (Same exception can be thrown if we're using it in inner and outer catch block).

17.
try {
	try {

	}
}
catch(X e) {

}
-Invalid (compuilation error, inner try is without catch/finally)

18.
try {

}
catch(X e) {
	try {

        }
	catch(X e) {

	}
}
-Valid

19.
try {

}
catch(X e) {

}
finally {
	try {

	}
	catch(X e) {

       	}
	finally {

	}
}
-Valid

20.
try
  sop("try")';
catch(X e) {
  sop("catch");
}
-Invalid (curly braces is mandatory for try)

21.
try {
  sop("try")';
}
catch(X e)
  sop("catch");

-Invalid (curly braces is mandatory for catch)

22.
try {
  sop("try")';
}
catch(X e) {

}
finally
  sop("finally");
-Invalid (curly braces is mandatory for finally)

NOTE: In try/catch/finally order is important. We cannot change the order.
      We can take one try block with multiple catch block but only one finally block.
      Multiple catch blocks we can take but multiple try blocks and multiple finally blocks we cannot take.
      Whenever we're writing try block either catch or finally must be required.
      Try without catch or finally is invalid.
      Whenever we're writing catch block compulsory try block should be there. Catch without try is invalid.
      Finally without try is invalid.
      Try with multiple catch block is possible but for same exception two catch blocks if we're writing then compilation error.
---------------------------------------------------------------------------------------------------------------------------------------

NEED OF THROW KEYWORD:
-throw keyword is the best choice if we have to throw customized exception. It is not for inbuilt exception(best use for customized exception).
-To handover custom exception or our created exception object manually to JVM to indicate something is going wrong and we're stopping our program. If we have this
 kind of requirement then we should use throw keyword.

e.g.
public class ThrowKeywordExample {

	public static void main(String[] args) {
		
		throw new ArithmeticException("divide by zero");
	}

}

O/P:
Exception in thread "main" java.lang.ArithmeticException: divide by zero
	at com.ExceptionHandling.ThrowKeywordExample.main(ThrowKeywordExample.java:7)

e.g.
public class ThrowKeywordExample {

	public static void main(String[] args) {
		
		int age = 16;
		
		if(age < 18) {
			throw new ArithmeticException("you are not an adult");
		}
		else {
			System.out.println("you are an adult");
		}	
	}
}

O/P:
Exception in thread "main" java.lang.ArithmeticException: you are not an adult
	at com.ExceptionHandling.ThrowKeywordExample.main(ThrowKeywordExample.java:10)

CASE 1: 
public class ThrowKeywordExample {
	
	static ArithmeticException ae = new ArithmeticException("custom exception");

	public static void main(String[] args) {
		
	    throw ae;	
	}
}

O/P:
Exception in thread "main" java.lang.ArithmeticException: custom exception
	at com.ExceptionHandling.ThrowKeywordExample.<clinit>(ThrowKeywordExample.java:5)

CASE 2:
public class ThrowKeywordExample {

	static ArithmeticException e;

	public static void main(String[] args) {
		throw e;
		
	}

}

O/P:
Exception in thread "main" java.lang.NullPointerException
	at com.ExceptionHandling.ThrowKeywordExample.main(ThrowKeywordExample.java:20)

-In this case, if we're throwing object for null reference then it will throw NullPointerException.
-In this case no new object is created. e has a null value so it will throw NullPointerException.
-If e refers null then we'll get NullPointerException but not corresponding exception.

CASE 3:
e.g.
class Test {

	public static void main(String[] args) {
		System.out.println(10/0);
		System.out.println("hello");        
        }

}

O/P:
Runtime exception - ArithmeticException: / by zero

-In this case compiler does not know that it will throw ArithmeticException.

CASE 4:
e.g.
public class ThrowKeywordExample2 {

	public static void main(String[] args) {
		
		throw new ArithmeticException("divide by zero");
		System.out.println("hello");
	}

}
-Here in this case compiler is aware that here it is going to throw ArithmeticException so sysout is not reachable.
-After throw statement we cannot write any statement directly. By mistake if we write any statement we'll get compile-time error.


CASE 5:
e.g.
public class CustomException {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

public class ThrowKeywordExample3 {

	public static void main(String[] args) {

		throw new CustomException();  //compilation error, No exception of type CustomException can be thrown; an exception type must be a subclass of Throwable.
	}

}

-throw keyword is only applicable for Throwable classes (Exception and Error). We cannot use throw keyword for a normal class(it has to be subclass of Throwable)
-If you want to remove the above compilation error then we have to extend the CustomException with RuntimeException.
e.g.
public class CustomException extends RuntimeException {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

public class ThrowKeywordExample3 {

	public static void main(String[] args) {

		throw new CustomException();  //OK
	}

}

  Throwable
      |
  Exception
      |
 RuntimeException
      |
 CustomException

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

THROWS KEYWORD:
-In our program if there is a chance of raising checked exception compulsory we should handle checked exception otherwise the code won't compile.
e.g.
public class ThrowsKeywordExample {

	public static void main(String[] args) {
		
		PrintWriter pw = new PrintWriter("abc.txt");  //compilation error, Unhandled exception type FileNotFoundException
		pw.println("hello");
	}

}

public class ThrowsKeywordExample {

	public static void main(String[] args) throws FileNotFoundException {
		
		PrintWriter pw = new PrintWriter("abc.txt");
		pw.println("hello");
	}

}

Q.How to handle checked exceptions?
1.try-catch --> already done
e.g.
public class TryCatchMethod {

	public static void main(String[] args) {
		try {
			Thread.sleep(1000);
		}
		catch(InterruptedException ie) {
			
		}
	}

}

2.throws keyword
-Purpose of throws keyword is to delegate the responsibilities of exception handling to the caller.
e.g.
public class TryCatchMethod {

	public static void main(String[] args) throws InterruptedException {
		
			Thread.sleep(1000);	
	}
}

-Best approach is try-catch to handle the exception. If we use throws keyword then if at runtime any exception is occured then there is chance of abnormal termination.
-throws keyword is used for checked exception.
-Uses of throws keyword for unchecked exceptions is meaningless. It is required for checked exceptions.
-throws keyword is required only for informing to the compiler and it does not prevent abnormal termination.

e.g.
public class ThrowsKeywordExample2 {

	public static void main(String[] args) throws InterruptedException {
		doStuff();  //line 1
	}
	
	public static void doStuff() throws InterruptedException {
		doMoreStuff();  //line 2
	}
	
	public static void doMoreStuff() throws InterruptedException {
		Thread.sleep(1000);  //line 3
	}

}

-If we do not use throws keyword anywhere in the above example then we'll get compilation error at line 3 then we use throws keyword at doMoreStuff(), but after
 that we get a compilation error at line 2 bcoz doStuff() is the caller of doMoreStuff(), so we have to use either try-catch or throws keyword at doStuff(), but
 now we'll get compilation error at line 1 bcoz main() is the caller of doStuff() which also has to use try-catch or throws keyword.

NOTE: Every caller method has to throw same exception or parent.

-throws keyword is valid with methods because it is called from some other methods of JVM.
-throws keyword is also valid for constructor.
-throws keyword is not used with class name because it is not called from any other classes or method. So it does not have any caller. So it will give compile-time error.

e.g.
public class CustomException2 {
	
}

public class ThrowsKeywordExample3 {

	public static void main(String[] args) throws CustomException2{  //No exception of type CustomException2 can be thrown; an exception type must be a subclass of Throwable
		// TODO Auto-generated method stub
		
	}

}

-We can use throws keyword to Throwable types as we can see as class CustomException2 is not Throwable type. To remove this error we have to extend CustomException2 either by Throwable/RuntimeException/Exception.
modified above e.g.
public class CustomException2 extends Exception {
	
}

public class ThrowsKeywordExample3 {

	public static void main(String[] args) throws CustomException2{
		// TODO Auto-generated method stub
		
	}

}

----------------------------------------------------------------------------------------------------------------------------------
e.g.
public class Test5 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		throw new Exception();   //throwing partially checked exception  //compilation error, Unhandled exception type
	}

}

-Above example will give compile tim error: Unhandled exception type
-If there is a checked exception, compulsory we have to handle it either by throws or by try-catch.
-If there is fully unchecked exception, we dont have to write anything.

public class Test5 {

	public static void main(String[] args) throws Exception {   //works fine now
		// TODO Auto-generated method stub
		throw new Exception();   //throwing partially checked exception
	}

}

----------------------------------------------------------------------------------------------------------------------------------
e.g.
public class Test5 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		throw new Error();    //works fine
	}
}

-In the above example it will not give any compilation error. In this case error is not checked so happily the code will compile fine, but at runtime
 it will give exception.

----------------------------------------------------------------------------------------------------------------------------------------

e.g.
public class Test5 {

	public static void main(String[] args) {
		try {
			sop("hello");
                }
                catch(IOException e) {    //compile time error, since IOException is fully checked exception and compiler is not getting any statement that will throw
                                          //the corresponding fully-checked exception.

		}
	}
}

public class Test5 {

	public static void main(String[] args) {
		try {
			sop("hello");
                }
                catch(InterruptedException e) {    //compile time error, since InterruptedException is fully checked exception and compiler is not getting any statement that will throw
                                          //the corresponding fully-checked exception.

		}
	}
}

-It will give compile-time error because InterruptedException is fully checked.

e.g.
public class Test5 {

	public static void main(String[] args) {
		try {
			PrintWriter pw = new PrintWriter("abc.txt");
                }
                catch(IOException e) {   //works fine because it is getting the statement which can throw IOException.

		}
	}
}

---------------------------------------------------------------------------------------------------------------------------
e.g.
public class Test5 {

	public static void main(String[] args) {
		try {
			sop("hello");
                }
                catch(Error e) {   //works fine since Error is fully-unchecked. 

		}
	}
}

RULE:
-Within try block if there is no chance of raising any exception then we can not write catch block for that exception.
-If we're writing any code in try block and that code is not throwing any checked exception then we don't have to write any checked exception in 
 catch block otherwise it will give compile-time error.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
EXCEPTION HANDLING KEYWORDS SUMMARY:
1.try
  To maintain risky code

2.catch
  To maintain handling code.

3.finally
  To maintain cleanup code.

4.throw
  To handover created exception object to the JVM manually.

5.throws
  To delegate resposibilities of exception handling to the caller.

------------------------------------------------------------------------------------------------------------------------------------------------------------
VARIOUS POSSIBLE COMPILE-TIME ERRORS IN EXCEPTION HANDLING:
1.try without catch/finally
2.catch without try
3.finally without try
4.unreported exception/ unhandled exception - must be declared or to be thrown in case of fully checked.

-----------------------------------------------------------------------------------------------------------------------------------------------
Q.DIFFERENCE BETWEEN FINAL, FINALLY AND FINALIZE?
-finalize() method is meant for cleanup code. It is called by the GC.
-finally block is meant for clean up code and will execute always.
-final is a keyword which is applicable to variable, method and class.

----------------------------------------------------------------------------------------------------------------------------------------------------

USER-DEFINED OR CUSTOM EXCEPTION:
-Sometimes we have to give exceptions according to our requirements. That exception is called custom exception or user-defined exception.
-The exception which is defined by programmer explicitly, those exceptions are called custom exceptions.

HOW TO DEFINE CUSTOM EXCEPTION?
e.g.

public class TooYoungException extends RuntimeException {

	TooYoungException(String msg) {
		super(msg);
		
	}
	
}

public class TooOldException extends RuntimeException {

	public TooOldException(String msg) {
		super(msg);
		// TODO Auto-generated constructor stub
	}

	
}

public class CustomException {

	public static void main(String[] args) {
		int age = 16;
		if(age < 18) {
			throw new TooYoungException("You are too young");
		} 
		else if(age > 18) {
			throw new TooOldException("You are too old bro");
		} 
		else {
			System.out.println("Register first");
		}

	}
}

NOTE: throw keyword is required bcoz it handles or raises the exception object manually and handover to JVM bcoz JVM is not aware of TooYoungException and
      TooOldException.

Q.What is the need of super(msg)?
  To make the description available to Throwable class.

-When we are not using catch to handle exception then that termination is abnormal termination. So, when abnormal termination JVM's default exception handler is used to 
 print the exception on console. here default dispatcher handler printStackTrace() method which is present in Throwable class and then print the exception on console.
 So here when we pass any message to constructor, that message is passed to parent class constructor to print the exception.

Q.Why it is highly recommended to extend class with RuntimeException class?
-If we don't use RuntimeException and we use Exception then it is partially checked which is checked by compiler and it will give compile time error.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

THREE IMPORTANT POINTS OF EXCEPTION HANDLING:
1.throw keyword is best suitable for customized exception not for pre-defined exception.
2.super(msg) is use to make the description available to handler.
3.If we want to make our exception as unchecked exception not checked therefore highly recommended to extend RuntimeException otherwise we have to use try-catch.
3rd point e.g.
public class CustomExceptionExample2 {

	public static void main(String[] args) {
		int age = 17;
		
		try {
			if(age < 18) {
				throw new TooYoungException("You are too young bro");
			}
		}
		catch(TooYoungException tye) {
			System.out.println("caught the exception");
		}

	}
}

O/P:
caught the exception

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

MULTI-THREADING:

INTRODUCTION:
Multi-Tasking:
-Executing several tasks simultaneously is the concept of multi-tasking.
 There are two types of multi-tasking:
 1.Process-based multi-tasking.
 2.Thread-based multi-tasking.

Process-based Multi-Tasking:
-Executing several tasks simultaneously where each task is a separate independent program(process) is called process-based multi-tasking.
-While typing a java program in the editor we can listen to audio songs form same system at same time. We can download a file from internet.
 All these tasks will be executed simultaneously and independent of each other hence it is called process-based multi-tasking.
-Process-based multi-tasking is best suitable at OS level.

Thread-based multi-tasking:
-Executing several tasks simultaneously where each task is a separate independent part of a same program is thread-based multi-tasking and each
 independent part is called a thread.
-Thread-based multi-tasking is best suitable at programmer level.
 
Advantages:
-Whether it is a process-based or thread-based the main purpose of multi-tasking is to reduce the response time of the system and to improve performance.

Where we use?
-The main imp. application of multi-threading are to develop the multi-media graphics, to develop animations, to develop video games, to develop web-server and
 to develop application server.
-When compared with old languages developing multi-threaded applications is very easy beacuse java provides inbuilt support for multi-threading with rich API of
 threads Runnable, ThreadGroup, etc.

How to define a thread in Java?
-We can define a thread in following two ways:
 1.By extending Thread class.
 2.By implmenting Runnable interface.

1.By extending Thread class:
e.g.
public class MyThread extends Thread{
	
	public void run() {
		for(int i = 0; i < 10; i++) {            //job of the child thread to execute
			System.out.println("Child Thread");
		}
	}
}

public class ThreadDemo {

	public static void main(String[] args) {
		
		MyThread mt = new MyThread(); //thread instantiation
		mt.start();  //starting of a new thread (child thread)
		
		for(int i = 0; i < 10; i++) {   //executed by main thread
			System.out.println("Main Thread");
		}
	}

}

-In the above program there are two thread main thread and child thread.
-main thread is responsible to start child thread.
-main() method is not a thread but main method is executed by main thread. main thread is responsible to execute main() method.

CASE 1: Thread Scheduler:
-It is the part of JVM and it is responsible to schedule thread i.e., if multiple threads are waiting to get a chance of execution then in whcih order
 thread will be executed will be decided by Thread Scheduler.
-We cannot accept exact algorithm followed by thread scheduler. It is varied from JVM to JVM. Hence, we cannot expect threads execution order and exact
 output and hence whenever situation comes for multi-threading there is no guarantee for exact output but we can provide several possible ouputs.

Q.Difference betweem mt.start() method and mt.run() method ?
-In the case mt.start() method a new thread will be created which is responsible for the execution of run() method internally.
-But in the case of normal mt.run() method call a new thread won't be created and run() method will be executed just like as normal method call
 by main thread.
-Hence in the above program if we replace mt.start() call with mt.run() call then the O/P will be:
 e.g.
 public class ThreadDemo {

	public static void main(String[] args) {
		
		MyThread mt = new MyThread(); //thread instantiation
		mt.run();  //starting of a new thread (child thread)
		
		for(int i = 0; i < 10; i++) {   //executed by main thread
			System.out.println("Main Thread");
		}
	}

 }

 O/P:
 Child Thread
 Child Thread
 Child Thread
 Child Thread
 Child Thread
 Child Thread
 Child Thread
 Child Thread
 Child Thread
 Child Thread
 Main Thread
 Main Thread
 Main Thread
 Main Thread
 Main Thread
 Main Thread
 Main Thread
 Main Thread
 Main Thread
 Main Thread

-This total o/p is created by main thread.

Q.Importance of start() method of Thread class:
-start() method of Thread class is responsible to register the thread with Thread Scheduler and all other mandatory activites hence without executing Thread class 
 start() method there is no chance of starting a new thread in Java. Due to this, Thread class start() method is considered as the heart of multi-threading.
 
 start()
 {
   1.register a new thread with thread scheduler.
   2.perform all other mandatory activites.
   3.invoke run()
 }
-----------------------------------------------------------------------------------
Overloading of run() method:
-Overloading of run() method is always possible but Thread class start() method can invoke no-args run() method. The other overloaded methods we have to call
 explicitly like a normal method.

e.g.
public class MyThread extends Thread{
	
	public void run() {
		System.out.println("no-args run method");
	}
	
	public void run(int a) {
		System.out.println("int-args run method");
	}
}

public class ThreadDemo {

	public static void main(String[] args) {
		
		MyThread mt = new MyThread(); //thread instantiation
		mt.start();  //starting of a new thread (child thread)
		
		for(int i = 0; i < 10; i++) {   //executed by main thread
			System.out.println("Main Thread");
		}
	}

}

O/P:
Main Thread
Main Thread
Main Thread
Main Thread
Main Thread
Main Thread
no-args run method
Main Thread
Main Thread
Main Thread
Main Thread

NOTE: If we're not overriding run() method then Thread class run() method will be executed which has empty implementation. Hence, we won't get any output.
e.g.
public class MyThread extends Thread{
	
}

public class ThreadDemo {

	public static void main(String[] args) {
		
		MyThread mt = new MyThread(); //thread instantiation
		mt.start();  //starting of a new thread (child thread)
		
	}

}

O/P: no o/p

NOTE: It is highly recommended to override the run() method otherwise don't go for multithreading concept.
------------------------------------------------------------------------------------------------------------------------
Overriding of start() method:
-If we override start method then out start() method will be executed just like normal method and new thread won't be created.
e.g.
public class MyThread extends Thread{
	public void start() {
		System.out.println("my start method");
	}
	
	public void run() {
		System.out.println("run method");
	}
}

public class ThreadDemo {

	public static void main(String[] args) {
		
		MyThread mt = new MyThread();
		mt.start();
		
	}

}

O/P: my start method (produced by main thread)

NOTE: It is not recommended to override start() method otherwise don't go for mutlithreading concepts.
e.g.
public class MyThread extends Thread{
	public void start() {
		super.start();
		System.out.println("my start method");
	}
	
	public void run() {
		System.out.println("run method");
	}
}

public class ThreadDemo {

	public static void main(String[] args) {
		
		MyThread mt = new MyThread();
		mt.start();
		System.out.println("main thread");
	}

}

O/P:
my start method
main thread
run method
(cannot determine the sequence of the output).

------------------------------------------------------------------------------------------------
LIFECYCLE OF THREAD:
   
                                         			           If thread scheduler
MyThread mt = new Mythread();   mt.start()                                 allocates processor               If run() completed
     New Born ---------------------------------------->  Ready/Runnable --------------------------> Running --------------------> Dead.

-After starting thread if we want to again restart the same thread then we'll get IllegalThreadStateException.
e.g.
public class MyThread extends Thread{
	public void start() {
		super.start();
		System.out.println("my start method");
	}
	
	public void run() {
		System.out.println("run method");
	}
}

public class ThreadDemo {

	public static void main(String[] args) {
		
		MyThread mt = new MyThread();
		mt.start();
		System.out.println("main thread");
		mt.start();
	}

}

O/P:
my start method
run method
main thread
Exception in thread "main" java.lang.IllegalThreadStateException
	at java.base/java.lang.Thread.start(Thread.java:794)
	at com.MultiThreading.MyThread.start(MyThread.java:18)
	at com.MultiThreading.ThreadDemo.main(ThreadDemo.java:15)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Defining a Thread by implementing Runnable interface:
-Runnable interface present in java.lang package and it contains only one abstract method run().
 public abstract void run();

e.g.
public class MyRunnable implements Runnable {

	@Override
	public void run() {
		for(int i = 0; i < 10; i++) {
			System.out.println("child thread");
		}
		
	}

}

public class ThreadDemo2 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		MyRunnable r = new MyRunnable();
		Thread t = new Thread(r);
		t.start();
		
		for(int i = 0; i < 10; i++) {
			System.out.println("main thread");
		}
	}

}

O/P:
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
child thread
(output sequence is decided as how thread scheduler schedules thread).

CASE STUDY:
MyRunnable r = new MyRunnable();
1.Thread t1 = new Thread();
2.Thread t2 = new Thread(r);

CASE 1: t1.start()
A new thread will created and which is responsible for the execution of Thread class run() method which has empty implmentation.

CASE 2: t1.run()
No new thread will be created and Thread class run() method will be executed as a normal method call.

CASE 3: t2.start()
A new thread will be created which responsible for the execution of MyRunnable class run() method.

CASE 4: t2.run()
No new thread will be created and MyRunnable class run() method will be executed as a normal method call.

CASE 5: r.start()
We will get compile-time error saying MyRunnable does not have start() method.

CASE 6: r.run()
No new thread will be created and MyRunnable class run() method will be executed as a normal method call.

Q.Which approach is the best to define a thread?
-Among two ways of defining a thread, implements Runnable approach is recommended.
-In the first approach our class always extends Thread class. There is no chance of extending any other class. Hence, we're misusing inheritance
 benefit.
-But in the second approach by implementing Runnable interface we can extend any other class. Hence, we won't miss any other inheritance benefit.
-Beacuse of above reasons implements Runnable interface approach is recommended than extending Thread class.

---------------------------------------------------------------------------------------
THREAD CLASS CONSTRUCTOR:
1.Thread t = new Thread();
2.Thread t = new Thread(Runnable r);
3.Thread t = new Thread(String name);
4.Thread t = new Thread(Runnable r, String name);
5.Thread t = new Thread(ThreadGroup g, String name);
6.Thread t = new Thread(ThreadGroup g, Runnable r);
7.Thread t = new Thread(ThreadGroup g, Runnable r, String name);
8.Thread t = new Thread(ThreadGroup g, Runnable r, String name, Long stackSize);
------------------------------------------------------------------------------------------
GETTING AND SETTING THREAD NAME:
-Every thread in java has some name it may be default name generated by JVM or customized name provided by programmer.
-We can get or set name of the thread by using following two methods:
 1.public final String getName();
 2.public final void setName();

e.g.
public class MyThread extends Thread{
	
	public void run() {
		for(int i = 0; i < 10; i++) {            //job of the child thread to execute
			System.out.println("Child Thread");
		}
		System.out.println("no-args run method");
	}
}

public class ThreadDemo3 {

	public static void main(String[] args) {
		System.out.println(Thread.currentThread().getName());
		MyThread t = new MyThread();
		Thread.currentThread().setName("Sarthak_Shivgan");
		System.out.println(Thread.currentThread().getName());
	}
}

O/P:
main
Sarthak_Shivgan

e.g.
public class MyThread extends Thread{
	
	public void run() {
		for(int i = 0; i < 10; i++) {            //job of the child thread to execute
			System.out.println("Child Thread");
		}
		System.out.println("no-args run method");
	}
}

public class ThreadDemo3 {

	public static void main(String[] args) {
		System.out.println(Thread.currentThread().getName());
		MyThread t = new MyThread();
		System.out.println(t.getName());
		Thread.currentThread().setName("Sarthak_Shivgan");
		System.out.println(Thread.currentThread().getName());
	}
}

O/p:
main
Thread-0
Sarthak_Shivgan

e.g.
public class MyThread extends Thread{
	
	public void run() {
		for(int i = 0; i < 10; i++) {            //job of the child thread to execute
			System.out.println("Child Thread");
		}
		System.out.println("no-args run method");
	}
}

public class ThreadDemo3 {

	public static void main(String[] args) {
		System.out.println(Thread.currentThread().getName());
		MyThread t = new MyThread();
		System.out.println(t.getName());
		t.setName("Durga");
		System.out.println(t.getName());
		Thread.currentThread().setName("Sarthak_Shivgan");
		System.out.println(Thread.currentThread().getName());
	}
}

O/P:
main
Thread-0
Durga
Sarthak_Shivgan

NOTE: We can get current executing thread object by using Thread.currentThread() .

e.g.
public class MyThread extends Thread{
	
	public void run() {
		System.out.println("run method executed by : " + Thread.currentThread().getName());
	}
}


public class ThreadDemo3 {

	public static void main(String[] args) {
		
		System.out.println(Thread.currentThread().getName());
		MyThread t = new MyThread();
		t.start();
		System.out.println("main method executed by : " + Thread.currentThread().getName());
	}
}

O/P:
main
main method executed by : main
run method executed by : Thread-0

----------------------------------------------------------------------------------------------------------------
THREAD PRIORITIES:
-Every thread in java has some priority. It may be default priority generated by JVM or customized priority provided by programmer.
-The valid range of thread priorities is 1 to 10 where is 1 is min priority and 10 is priority.
-Thread class defines the following constants to represent some standard priorities.
 1.Thread.MAX_PRIORITY   //10
 2.Thread.MIN_PRIORITY   //1
 3.Thread.NORM_PRIORITY  //5

Q.Which of the following is valid ?
  1.Thread.MIN_PRIORITY    //valid
  2.Thread.MAX_PRIORITY    //valid
  3.Thread.LOW_PRIORITY    //invalid
  4.Thread.HIGH_PRIORITY   //invalid

-Thread Scheduler will use priorities while allocating processors. The thread which is having highest priority will get the chance first and then next priorities.
-If two threads having same priority we cannot expect exact execution order. It depends on Thread Scheduler.
-Thread class defines the following methods to get and set priorities:
 1.public final int getPriority();
 2.public final void setPriority(int p);   //allowed value range for p is 1 to 10 otherwise we'll get runtime exception IllegalArgumentException.

Default Priorities:
-The default priority for the main thread is 5. But, for all remaining thread default priority will be inherited from parent to child i.e., whatever priority
 parent thread has the same priority will be there for child.

e.g.
public class MyThread extends Thread{
	
	public void run() {
		System.out.println("run method executed by : " + Thread.currentThread().getName());
	}
}


public class ThreadDemo3 {

	public static void main(String[] args) {

		System.out.println(Thread.currentThread().getPriority());
		Thread.currentThread().setPriority(10);
		System.out.println(Thread.currentThread().getPriority());
		MyThread t = new MyThread();
		t.start();
		System.out.println(t.getPriority());
	}
}

O/P:
5
10
10
run method executed by : Thread-0

NOTE: Some Platform won't provide proper support for thread priorities.
e.g.
public class MyThread extends Thread{
	
	public void run() {
		for(int i = 0; i < 10; i++) {            //job of the child thread to execute
			System.out.println("Child Thread");
		}
		System.out.println("no-args run method");
	}
}

public class ThreadDemo3 {

	public static void main(String[] args) {

		MyThread t = new MyThread();
		t.setPriority(10);
		t.start();
		for(int i = 0; i < 10; i++) {
			System.out.println("main thread");
		}
	}
}

O/P:
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
Child Thread
Child Thread
Child Thread
Child Thread
Child Thread
Child Thread
Child Thread
Child Thread
Child Thread
Child Thread
no-args run method

-We can prevent thread execution by using following methods:
 1.yield()
 2.join()
 3.sleep()

1.yield() method:
  This method is used to pause current executing thread to give the chance for waiting thread of same priority. If there is no waiting thread or all the waiting
  threads have low priority then same thread can continue it's execution.
  If multiple threads are waiting with same priority then which waiting thread will get the chance we cannot expect, it depends on Thread Scheduler.
  The thread which is yield when it will get the chance once again it depends upon Thread Scheduler and we cannot expect exactly. 

  Syntax:
  public static native yield();
  
  e.g.
  public class MyThread extends Thread{
	
	public void run() {
		for(int i = 0; i < 10; i++) {            //job of the child thread to execute
			System.out.println("Child Thread");
			Thread.yield();
		}
	}
  }
 
  public class ThreadDemo3 {

	public static void main(String[] args) {
		
		MyThread t = new MyThread();
		t.start();
		for(int i = 0; i < 10; i++) {
			System.out.println("main thread");
		}
	}
  }

O/P:
main thread
main thread
main thread
main thread
main thread
Child Thread
Child Thread
Child Thread
Child Thread
Child Thread
Child Thread
main thread
main thread
main thread
main thread
main thread
Child Thread
Child Thread
Child Thread
Child Thread

NOTE: Some Platform won't provide proper support for yield() method.

2.join() method:
-If a thread wants to wait until completing some other thread then we should go for join() method.
For e.g. If a thread t1 wants to wait until completing t2 then t1 has to call t2.join(). If t1 executes t2.join() then immediately t1 will enter into waiting
         state until t2 completes. Once t2 completes then t1 can continue it's execution.

-Wedding card printing (Thread t2) has to wait until Venue fixing thread(t1) completes. Hence, t2 has to call t1.join().
-Wedding card distribution(Thread t3) has to wait until Wedding card printing(Thread t2) completion. Hence, t3 has to call t2.join().

Syntax:
1.public final void join();
  Wait until another thread got completed.
2.public final void join(long ms);
  Wait until specified hours/minutes.
3.public final void join(long ms, int ns);
  Wait until specified hours, minutes, seconds.
  
NOTE: Every join() methods throws InterruptedException which is checked exception hence compulsory we should handle this exception by using either try-catch or
      by using throws otherwise we'll get compile-time error.
e.g.
public class MyThread extends Thread{
	
	public void run() {
		for(int i = 0; i < 10; i++) {            //job of the child thread to execute
			System.out.println("Seeta Thread");
		}
	}
}

public class ThreadDemo3 {

	public static void main(String[] args) throws InterruptedException {
		
		MyThread t = new MyThread();
		t.start();
		t.join();  //line 1
		for(int i = 0; i < 10; i++) {
			System.out.println("main thread");
		}
	}
}

O/P:
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread
main thread

-If we comment line 1 then both the main and child thread will be executed simultaneously and we cannot exact output.
-If we're not commenting line 1 then main thread call join() method on child thread object hence main thread will wait until completion of child thread.
 In this case o/p will be as shown above.

NOTE: t.join() matlab 't' thread ka complete hone ka wait karenge.

e.g.
Child thread waiting for main thread to execute.
public class ThreadDemo3 {

	public static void main(String[] args) throws InterruptedException {
		
		MyThread.mainThread = Thread.currentThread();
		MyThread t = new MyThread();
		t.start();
		for(int i = 0; i < 10; i++) {
			System.out.println("Ram Thread");
		}
	}
}

public class MyThread extends Thread {
	
	static Thread mainThread;
	
	public void run() {
		try {
			mainThread.join();
		} catch(InterruptedException ie) {
			ie.printStackTrace();
		}
		for(int i = 0; i < 10; i++) {       //job of the child thread to execute
			System.out.println("Seeta Thread");
		}
	}
}

O/P:
Ram Thread
Ram Thread
Ram Thread
Ram Thread
Ram Thread
Ram Thread
Ram Thread
Ram Thread
Ram Thread
Ram Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread
Seeta Thread

e.g.
public class ThreadDemo3 {

	public static void main(String[] args) throws InterruptedException {
		
		MyThread.mainThread = Thread.currentThread();
		MyThread t = new MyThread();
		t.start();
		t.join();
		for(int i = 0; i < 10; i++) {
			System.out.println("Ram Thread");
		}
	}
}

public class MyThread extends Thread {
	
	static Thread mainThread;
	
	public void run() {
		try {
			mainThread.join();
		} catch(InterruptedException ie) {
			ie.printStackTrace();
		}
		for(int i = 0; i < 10; i++) {       //job of the child thread to execute
			System.out.println("Seeta Thread");
		}
	}
}

O/P:
DEADLOCK

3.sleep() method:
-If a thread don't want to perform any operation for a particular amount of time then we should go for sleep() method.
 Type of methods:
 1.public static native void sleep(long ms) throws InterruptedException;
 2.public static native void sleep(long ms, int ns) throws InterruptedException;

NOTE: Every sleep() method throws InterruptedException which is checked exception.Hence, whenever we're using sleep() compulsory we should handle InterruptedException either
      by try-catch or throws.

e.g.
public class ThreadDemo3 {

	public static void main(String[] args) throws InterruptedException {
		
		for(int i = 0; i < 10; i++) {
			System.out.println("Ram Thread");
			Thread.sleep(5000);
		}
	}
}

Q.How a thread can interrupt another thread?
-A thread can interrupt a sleeping thread or waiting thread by using interrupt() method of Thread class.
 Syntax:
 public void interrupt();

e.g.

public class MyThread extends Thread {
	
	static Thread mainThread;
	
	public void run() {
		try {
			for(int i = 0; i < 10; i++) {
				System.out.println("i am a lazy thread");
				Thread.sleep(2000);
			}
		} catch(InterruptedException e) {
			System.out.println("i got interrupted");
		}
	}
}

public class ThreadDemo3 {

	public static void main(String[] args) throws InterruptedException {
		
		MyThread t = new MyThread();
		t.start();
		t.interrupt();  //line 1
		System.out.println("end of main");
	}
}

O/P:
end of main
i am a lazy thread
i got interrupted

-If we commment line 1 then main thread won't interrupt child thread. In this case child thread will execute 10 times.
-If we don't comment line 1 then main thread will interrupt child thread.

NOTE: 1.Whenever we're calling interrpt() if the target thread is not in sleeping state or waiting state then there is no impact of interrupt() call immediately.
        interrupt call will wait until target thread enter into sleeping or waiting state.
      2.If the target thread entered into sleeping or waiting state then immediatley interrupt call will be executed on target thread.
      3.If the target thread never entered into sleeping or waiting state in it's lifecycle then there is no impact of interrupt call. This is the only case where interrupt
        method call will be wasted.
e.g.
public class MyThread extends Thread {
	
	static Thread mainThread;
	
	public void run() {
		for(int i = 0; i < 10; i++) {
			System.out.println("i am a lazy thread");
		}
	}
}

public class ThreadDemo3 {

	public static void main(String[] args) throws InterruptedException {
		
		MyThread t = new MyThread();
		t.start();
		t.interrupt();  //line 1
		System.out.println("end of main");
	}
}

O/P:
end of main
i am a lazy thread
i am a lazy thread
i am a lazy thread
i am a lazy thread
i am a lazy thread
i am a lazy thread
i am a lazy thread
i am a lazy thread
i am a lazy thread
i am a lazy thread

COMPARISON TABLE OF YIELD, JOIN, SLEEP METHOD:

	PROPERTY                            YIELD                              			JOIN                                 SLEEP
       1.Purpose               1.If a thread wants to pause its execution	   1.If a thread wants to wait until       1.If a thread does not want to
                                 to give the chance for remaining threads            completion of some other thread         perform any operation for a 
				 of same priority then we should go for              then we should go for join() 	     a particular amount of time
				 this method.                                        method.                                 then we should go for sleep().

   2.Is it Overloaded?         2.No                                                2.Yes                                   2.Yes

   3.Is it final?              3.No                                                3.Yes                                   3.Yes

   4.Does it throw
     InterruptedException      4.No                                                4.Yes                                   4.Yes
 
   5.Is it static?             5.Yes                                               5.No                                    5.Yes

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SYNCHRONIZATION:
-synchronized is the modifier which is applicable for methods and blocks but not for classes and variables.
-If multiple threads are trying to operate simultaneously on the java object then there may a chance of data inconsistency problem.
-To overcome this problem we should go for synchronized keyword.
-If the method or block is declared as synchronized then at a time only one thread is allowed to execute that method or block on the given object. So that
 data inconsistency problem will be resolved.
-The main advantage of synchronized keyword is we can resolve data inconsistency problem but the main disadvantage of synchronized keyword is it increases waiting
 time of thread and creates performance problem. Hence, if there is no specific requirement then don't use synchronized.
-Internally synchronization concept is implemented by using lock.
-Every object in java has a unique lock. Whenever we're using synchronized keyword then only lock concept will come into picture.
-If a thread wants to execute a synchronized method on the given object, first it has to get the lock of the particular object. Once thread got the lock then it is
 allowed to execute any synchronized method on that object. Once method execution completes, automatically thread releases the lock of that object. This acquiring
 and releasing lock internally takes care by JVM and programmer is not responsible for this activity.
-While a thread executing synchronized method on a given object the remaining threads are not allowed to execute any synchronized method simulatneously on the same
 object. But remaining threads are allowed to executed non-synchronized method simultaneously.

e.g.
t1 thread starts to execute m1() method. If t2 thread comes to execute m1() it will go into waiting state. If t3 thread comes to execute m2() it will again go to
waiting state. If t4 thread comses to execute m3() then it is valid since m3() in non-synchronized.

NOTE: lock concept is implemented based on object but not based on method.

e.g.
Non-synchronized:
public class Display {
	public void wish(String name) {
		for(int i =0 ; i< 10; i++) {
			System.out.println("good morning : " + name);
		}
	}
}

public class MyThread extends Thread{
	Display d;
	String name;
	
	public MyThread(Display d, String name) {
		this.d = d;
		this.name = name;
	}
	
	public void run() {
		d.wish(name);
	}
}

public class SynchronizationDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Display d = new Display();
		MyThread t1 = new MyThread(d, "dhoni");
		MyThread t2 = new MyThread(d, "yuvraj");
		t1.start();
		t2.start();
	}

}

O/P:
good morning : dhoni
good morning : yuvraj
good morning : dhoni
good morning : yuvraj
good morning : dhoni
good morning : yuvraj
good morning : dhoni
good morning : yuvraj
good morning : dhoni
good morning : yuvraj
good morning : dhoni
good morning : yuvraj
good morning : dhoni
good morning : yuvraj
good morning : dhoni
good morning : yuvraj
good morning : dhoni

e.g.
Synchronized
public class Display {
	public synchronized void wish(String name) {
		for(int i =0 ; i< 10; i++) {
			System.out.println("good morning : " + name);
		}
	}
}

public class MyThread extends Thread{
	Display d;
	String name;
	
	public MyThread(Display d, String name) {
		this.d = d;
		this.name = name;
	}
	
	public void run() {
		d.wish(name);
	}
}

public class SynchronizationDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Display d = new Display();
		MyThread t1 = new MyThread(d, "dhoni");
		MyThread t2 = new MyThread(d, "yuvraj");
		t1.start();
		t2.start();
	}

}

O/P:
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj

-If we're not declaring wish() method as synchronized then both threads will be executed simultaneously and hence we'll get irregular output.
-If we declare wish() method as synchronized then at a time only thread is allowed to execute wish() method on the given display object hence we'll get regular output.
-------------------------------------------------------------------------------------------------

e.g.
public class Display {
	public synchronized void wish(String name) {
		for(int i =0 ; i< 10; i++) {
			System.out.println("good morning : " + name);
		}
	}
}

public class MyThread extends Thread{
	Display d;
	String name;
	
	public MyThread(Display d, String name) {
		this.d = d;
		this.name = name;
	}
	
	public void run() {
		d.wish(name);
	}
}

public class SynchronizationDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Display d = new Display();
		Display d1 = new Display();
		MyThread t1 = new MyThread(d, "dhoni");
		MyThread t2 = new MyThread(d1, "yuvraj");
		t1.start();
		t2.start();
	}

}

O/P:
good morning : dhoni
good morning : yuvraj
good morning : dhoni
good morning : yuvraj
good morning : dhoni
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : dhoni
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni

-Eventhough wish method is synchronized we'll get irregular output bcoz threads are operating on different java object.

Conclusion:
-If multiple threads are operating on same java object then synchronization is required.
-If multiple threads are operating on multiple java objects then synchronization is not required.

CLASS-LEVEL LOCK:
-Every class in java has a unique lock which is nothing but class-level lock.
-If a thread wants to execute a static synchronized method then thread require class-level lock.
-Once thread got class level lock it is allowed to execute any static synchronized method of that class.
-Once method execution completes automatically thread releases the lock.
-When a thread is executing static synchronized method the remaining threads are not allowed to execute any static synchronized method of that class
 simultaneously but reamining threads are allowed to execute normal methods simultaneously.

e.g.
public class Display {
	public static synchronized void wish(String name) {
		for(int i =0 ; i< 10; i++) {
			System.out.println("good morning : " + name);
		}
	}
}

public class MyThread extends Thread{
	Display d;
	String name;
	
	public MyThread(Display d, String name) {
		this.d = d;
		this.name = name;
	}
	
	public void run() {
		d.wish(name);
	}
}

public class SynchronizationDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Display d = new Display();
		Display d1 = new Display();
		MyThread t1 = new MyThread(d, "dhoni");
		MyThread t2 = new MyThread(d1, "yuvraj");
		t1.start();
		t2.start();
	}

}

O/P:
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj

----------------------------------------------------------------------------------------------------------------------------------------------------
SYNCHRONIZED BLOCK:
-If very few lines of code require synchronization then it is not recommended to declare entire method as synchronized.
-We have to enclose those few lines of code by using synchronized block.
-The main advantage of synchronized block over synchronized method is it reduce the waiting time of threads and improve performance of system.

1.To get lock of current object:
synchronized(this)
{
     .......
}
If a thread got lock of current object then only it is allowed to execute this area.

2.To get the lock of particular object:
synchronized(d)
{
     ......
}
If a thread got lock of a particular object then only it is allowed to execute this area.

3.To get the Class-level lock.
synchronized(Display.class)
{ 
    ......
}
If a thread got class-level lock of Display class then only it is allowed to execute.

e.g.
class-level lock:
public class Display {
	public void wish(String name) {
		synchronized(Display.class) {
			for(int i =0 ; i< 10; i++) {
				System.out.println("good morning : " + name);
			}
		}
	}
}

public class MyThread extends Thread{
	Display d;
	String name;
	
	public MyThread(Display d, String name) {
		this.d = d;
		this.name = name;
	}
	
	public void run() {
		d.wish(name);
	}
}

public class SynchronizationDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Display d = new Display();
		Display d1 = new Display();
		MyThread t1 = new MyThread(d, "dhoni");
		MyThread t2 = new MyThread(d1, "yuvraj");
		t1.start();
		t2.start();
	}

}

O/P:
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj

e.g.
object-level lock:
public class Display {
	public void wish(String name) {
		synchronized(this) {
			for(int i =0 ; i< 10; i++) {
				System.out.println("good morning : " + name);
			}
		}
	}
}

public class MyThread extends Thread{
	Display d;
	String name;
	
	public MyThread(Display d, String name) {
		this.d = d;
		this.name = name;
	}
	
	public void run() {
		d.wish(name);
	}
}

public class SynchronizationDemo {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Display d = new Display();
		MyThread t1 = new MyThread(d, "dhoni");
		MyThread t2 = new MyThread(d, "yuvraj");
		t1.start();
		t2.start();
	}

}

O/P:
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : dhoni
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj
good morning : yuvraj

NOTE:




-If we have two different objects in above class-level lock example and we call the method using two different threads then it will give irregular
 output as the lock type is object-level lock.
-But if we make synchronized block as class-level lock (synchronized(Display.class){...}) then this is class-level lock and this will give regular output.
 Because, only ont thread will be executed and other thread will go itno waiting state and wait for other thread to release the lock.

INTER-THREAD COMMUNICATION:
-Two threads can communicate by using wait(), notify() or notifyAll().
-The thread which is expecting updation is responsible to call wait() method then immediately the thread will enter into waiting state.
-The thread which is responsible to perform updation after performing updation it is responsible to call notify() method then waiting thread will get the
 notification and continue its execution with those updated items.

Q.Why wait(), notify() and notifyAll() are present in Object class not in Thread class?
-wait(), notify() and notifyAll() present in Object class but not in Thread class bcoz Thread can call these methods on any java object.

NOTE: To call wait(), notify() or notifyAll() on any java object Thread should be owner of that object i.e., the Thread should have the lock of that object i.e.,
      Thread should be inside synchronized area. Hence, we can call wait(), notify() and notifyAll() within synchronized area otherwise we'll get
      IllegalMonitorizationException.

-If a thread calls wait() method on any object it immediately release the lock of that particualr object and enter into waiting state.
-If a thread call notify() method on any object it releases the lock on that object but not immediately.
-Except wait(), notify() and notifyAll() there is no other method where thread releases the lock.

			METHODS                                             IS THREAD RELEASES LOCK?
			1.yield()						No
			2.join()						No
			3.sleep()						No
			4.wait()						yes
			5.notify()						yes
			6.notifyAll()						yes

Q.Which of the following is valid?
 1.If a thread calls wait() method immediately enter into waiting state without relasing lock - invalid
 2.If a thread calls wait() method it releases the lock of that object but may not immediately - invalid
 3.If a thread calls wait() method on any object it releases all locks acquired by that thread and immediately enter into waiting state - invalid (won't releases all locks)
 4.If a thread calls wait() method on any object it immediately release the lock of that particular object and entered into waiting state - valid
 5.If a thread calls notify() method on any object it immediately release the lock of that particular object - invalid
 6.If a thread calls notify() method on any object it releases the lock of that object but may not immediately - invalid

Syntax:
1.public final void wait() throws InterruptedException
2.public final native void wait(long ms) throws InterruptedException;
3.public final void wait(long ms, int ns) throws InterruptedException;

4.public final native void notify();
5.public final native void notifyAll();

-Every wait() method throws InterruptedException which is checked exception hence whenever we're using wait() method we should handle this InterruptedException either by
 try-catch or throws keyword otherwise we'll get compile-time error.

DIFFERENCE BETWEEN NOTIFY() AND NOTIFYALL():
-We can use notify() to give the notification for only one waiting thread. If multiple threads are waiting then only one thread will be notified and remaining
 all the threads have to wait for further notifications.
-Which thread will be notified we cannot expect it. It depends on JVM.
-We can use notifyAll() method to give the notification for all waiting threads of a particular object. Eventhough multiple threads notified but execution will
 be performed one by one bcoz thread requires lock and only one lock is available.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DAEMON THREAD:
-The threads which are executing in the background are called Daemon Threads.
 e.g. Garbage collector, Signal dispatcher, attach listener, etc.
-The main objective of daemon thread is to provide support for non-daemon thread.
e.g. If main thread runs with low memory then JVM runs garbage collector to destroy then JVM runs Garbage collector to destroy useless object so that number of
     bytes of free memory will be improved. With this free memory main thread can continue its execution.
-Usually the daemon thread having low priority but based on our requirement daemon thread can run with high priority also.

Q.How you can check the thread is daemon or not?
-We can check daemon nature of a thread by using isDaemon() method of Thread class.
 Syntax:
 public boolean isDaemon();

-We can change daemon nature of a thread by using setDaemon();
 Syntax:
 public void setDaemon(boolean b);

-But changing daemon nature is possible before starting of a thread only.
-After starting a thread if we're trying to change daemon nature we'll get runtime exception IllegalThreadStateException.

Q.What is the default nature of a thread?
-By default main thread is always non-daemon and for all remaining threads daemon nature will be inherited from parent to child i.e., if the parent thread is
 daemon then automatically child thread is also daemon. And if the parent thread is non-daemon then the child thread is also non-daemon.

-It is impossible to change daemon nature of main thread as it is already started by JVM at beginning.

NOTE: Whenever last non-daemon thread terminates automatically all daemon threads will be terminated irrespective of their position.

e.g.
public class MyThread2 extends Thread{
	public void run() {
		for(int i = 0; i < 10; i++) {
			System.out.println("child-thread");
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}

public class Test2 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		MyThread2 t = new MyThread2();
		
		t.setDaemon(true);
		t.start();
		System.out.println("end of main thread");
	}

}

O/P:
end of main thread
child-thread

-If we set child thread as daemon so when main thread executes completely then child thread will be aborted immediatley in case output will be as shown above.

Q.How to stop a thread?
-We can stop a thread execution by using stop() method of Thread class.
 Syntax: public void stop();
-If we call stop() method the thread will enter into dead state. Anyway stop() method is deprecated and not recommended to use.

Q.How to suspend or resume a thread?
-We can suspend a thread by using suspend method() of Thread class then immediately thread will enter into suspend state.
-We can resume a suspended thread by using resume() method of Thread class then suspended thread can continue its execution.
-Anyways these methods are deprecated and not recommended to use.

------------------------------------------------------------------------------------------------------------------------------------
EXECUTOR FRAMEWORK (THREADPOOL):
-Creating a new thread for every job may create performance issue and memory problem. To overcome this we should go for ThreadPool.
-ThreadPool is a pool of already created thread ready to do our job.
-Java 1.5 version introduced ThreadPool Framework.
-ThreadPool framework is also known as executor framework.

How we can create ThreadPool?
 ExecutorService service = Executor.newFixedThreadPool(3);

 service.submit(job);  //submitting runnable job

 service.shutdown();  //we can shutdown executor service by using this method.

e.g.
public class PrintJob implements Runnable{

	String name;
	
	public PrintJob(String name) {
		this.name = name;
	}
	
	@Override
	public void run() {
		System.out.println(name + " job completed successfully by Thread " + Thread.currentThread().getName());
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block

		}
		
	}
	
}

public class ExecutorDemo {

	public static void main(String[] args) {
		PrintJob[] jobs = {
							new PrintJob("Sachin"),
							new PrintJob("Dhoni"),
							new PrintJob("Sehwag"),
							new PrintJob("Kohli"),
						  };
		
		ExecutorService service = Executors.newFixedThreadPool(3);
		for(PrintJob job : jobs) {
			service.submit(job);
		}
		
		service.shutdown();
	}

}

O/P:
Sehwag job completed successfully by Thread pool-1-thread-3
Sachin job completed successfully by Thread pool-1-thread-1
Dhoni job completed successfully by Thread pool-1-thread-2
Kohli job completed successfully by Thread pool-1-thread-3

-In the above example three threads are responsible to execute 4 jobs so that a single thread can execute multiple jobs.

NOTE: Where Threadpool concept is really used?
      While designing web server and application server we can use ThreadPool concept.

Q.What is the difference between Callable and Runnable?
-When our job does not return anything the we use Runnable.
-But when our job returns somethinf to caller then we extend Callable interface. Instead of run() we should have call().
-Callable interface contains call().
-Runnable interface contains run().
-call() method return type is Object.

CALLABLE AND FUTURE:
-In the case of Runnable job thread won't return anything after completing the job. If the thread is reqd to return some result after execution
 then we should go for Callable.
-Callable interface contains only one method public Object call() throws Exception;
-If we submit Callable object to executor then after completing the job thread returns an object of type Future i.e., Future object can be used
 to retrieve the result from Callable jobs.

DIFFERENCE BETWEEN RUNNABLE AND CALLABLE:

		RUNNABLE					CALLABLE
1.If a thread does not return anything after	1.If ahtread reqd. to return something
  completing the job then we should go for        after completing the job then we should
  Runnable                                        go for Callable.

2.Contains only one method run()                2.Contains only one method call().

3.Return type of run() is void.                 3.Return type of call() is Object.
 
4.If there is any chance of raising checked     4.Inside call() method if there is any
  exception we handle it by only using            chance of raising checked exception
  try-catch bcoz we can't use throws for          we're not reqd. to handle by try-catch
  run method                                      bcoz call() already throws Exception in
                                                  interface.

5.Present in java.lang				5.Present in java.lang.concurrent

6.Introduced in 1.0v.                           6.Introduced in 1.5v.

-----------------------------------------------------------------------------------------------------------
THREADGROUP:
-Based on functionality we can group threads into a single unit which is nothing but ThreadGroup i.e., ThreadGroup contains a group of threads.
-In addition of thread group can also contain sub-threadgroup.
-The main advantage of maintaining thread in the form of threadgroup is we can perform common operations very easily.
-Every thread in java belongs to some group. Main thread belongs to main group. Every threadgroup in java is the child group of SystemGroup either
 directly or indirectly. Hence, SystemGroup acts as root for all threadgroups in java.
-SystemGroup contains several system-level threads i.e., Finalizer, ReferenceHandler, SignalDispatcher, AttachListener.
-ThreadGroup is a java class present in java.lang package and it is the direct child class of Object class.

CONSTRUCTORS OF THREADGROUP CLASS:
1.ThreadGroup tg = new ThreadGroup(String name);
  Creates a new ThreadGroup with the specified group name. The parent of this new group is the ThreadGroup of currently executing thread.

2.Threadgroup tg = new ThreadGroup(ThreadGroup tgr, String name);
  Creates a new ThreadGroup with the specified group name. The parent of this new ThreadGroup is specified Parent Group.

IMPORTANT METHODS:
1.String getName();
  Returns name of ThreadGroup

2.int getMaxPriority();
  returns max prioroty of threadgroup.

3.void setMaxPriority();
  set max priority of threadgroup.

-Threads in the ThreadGroup that have already higher priority won't be affected but for newly added threads this max-priority is applicable.

4.ThreadGroup getParent();
  returns parent group of current thread.

5.void List();
  It prints information about ThreadGroup to the console.

6.int activeCount();
  returns no. of active threads present in ThreadGroup.

7.int activeGroupCount();
  returns no. of active groups present in current Threadgroup.

8.int enumerate(Thread[] t);
  To copy all active thread of ThreadGroup into provided Thread array. In this sub-thread, group-thread will be considered.

9.int enumerate(ThreadGroup[] g);
  To copy all active subthreadgroup into ThreadGroup array.

10.boolean isDaemon();
   To check whether the ThreadGroup is daemon or not.

11.boolean setDaemon(boolean b);
   To set ThreadGroup as daemon.

12.void interrupt();
   To interrupt all the waiting or sleeping threads in ThreadGroup.

13.void destroy();
   To destroy ThreadGroup and all of its sub-ThreadGroup.

e.g.
public class ThreadDemo3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		ThreadGroup systemThread = Thread.currentThread().getThreadGroup().getParent();
		
		Thread[] t = new Thread[systemThread.activeCount()];
		systemThread.enumerate(t);
		
		for(Thread thread: t) {
			System.out.println(thread.getName());
		}
	}

}

O/P:
Reference Handler
Finalizer
Signal Dispatcher
Attach Listener
main
Common-Cleaner